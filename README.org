#+TITLE: Emacs News Highlights
#+OPTIONS: toc:1

| Talk page            | https://emacsconf.org/2021/talks/news            |rt
| Contact              | Sacha Chua [[mailto:sacha@sachachua.com][sacha@sachachua.com]]                             |
# | Video with subtitles | [[file:emacs-conf-2020-emacs-news-highlights-sacha-chua.webm]] |
# | Audio only           | [[file:audio.ogg]]                                             |

(* 5 150) 750

Draft of my talk for EmacsConf 2021 based on highlights from https://sachachua.com/emacs-news

* Talk plans
:PROPERTIES:
:CUSTOM_ID: script
:END:

#+CAPTION: Emacs News Highlights - emacsconf.org/2021/talks/news
[[file:images/Screenshot_20211021_002952.png]] 

I'm Sacha Chua, and here are 
ten Emacs News highlights for 2021.
If you want to follow the links,
check out the wiki page at
https://emacsconf.org/2021/talks/news/ .

#+CAPTION: 1. Emacs NEWS.28 - git.savannah.gnu.org/cgit/emacs.git/tree/etc/NEWS.28
[[file:images/Screenshot_20211020_095333.png]]

1. The Emacs developers are currently
   working on [[https://git.savannah.gnu.org/cgit/emacs.git/tree/etc/NEWS.28][Emacs 28.1]],
   which will be the next major release.

   #+CAPTION: Native compilation featured on System Crafters, www.youtube.com/watch?v=i8OLg-f9EHk
   [[file:images/Screenshot_20211020_095812.png]]
   
   [[https://www.youtube.com/watch?v=i8OLg-f9EHk][Native compilation]] should
   make everything way faster,

   #+CAPTION: Emoji support
   [[file:images/EmacslZhRzr.svg]]

   and emoji support will probably
   make things more fun. üòéüëç
   
   John Wiegley will share more Emacs 28 details
   in his update, so check out his talk.

2.
   #+CAPTION: 2. Org Mode 9.5 - orgmode.org/Changes.html
   [[file:images/Screenshot_20211020_100623.png]]

   [[https://orgmode.org/Changes.html][Org Mode is now at version 9.5]].
   New features include
   a library for [[https://blog.tecosaur.com/tmio/2021-07-31-citations.html#fn.3][managing citations]],

   #+CAPTION: asynchronous session support in Python - blog.tecosaur.com/tmio/2021-05-31-async.html
   [[file:images/org-async-python-demo.mp4]]
   
   [[https://blog.tecosaur.com/tmio/2021-05-31-async.html][asynchronous session support]]
   for code blocks,

   #+CAPTION: New faces for agenda - orgmode.org/Changes.html
   [[file:images/Screenshot_20211020_101636.png]]

   and better control
   of your [[https://orgmode.org/Changes.html][agenda's appearance]].
   
   #+CAPTION: Org Mode 9.5 - orgmode.org/Changes.html
   [[file:images/Screenshot_20211020_100623.png]]
   If you've been getting your Org packages
   from Org ELPA,
   you can update your configuration
   to get Org from GNU ELPA
   and org-contrib from NonGNU ELPA.

   #+CAPTION: Org Roam v2 - blog.jethro.dev/posts/org_roam_v2/
   [[file:images/Screenshot_20211020_101756.png]]

   The [[https://blog.jethro.dev/posts/org_roam_v2/][new release of the Org Roam package]] ([[https://blog.tecosaur.com/tmio/2021-08-38-roaming.html][TMIO]])
   should be a faster and more consistent way
   to use Org to manage a knowledgebase,

   #+CAPTION: Org Roam UI - github.com/org-roam/org-roam-ui/
   [[file:images/org-roam-ui.png]]
   
   and [[https://github.com/org-roam/org-roam-ui/][org-roam-ui]] looks pretty snazzy.

   #+CAPTION: blog.tecosaur.com/tmio
   [[file:images/Screenshot_20211020_101922.png]]

   The best way to keep up with Org changes
   is to check out the blog [[https://blog.tecosaur.com/tmio/][This Month in Org]].

3.
   #+CAPTION: 3. Magit 3 - emacsair.me/2021/05/25/magit-3.0/
   [[file:images/Screenshot_20211020_102028.png]]

   New [[https://emacsair.me/2021/05/25/magit-3.0/][Magit major release]]!
   Jonas Bernoulli has split some functionality
   into other packages so that
   Emacs Lisp developers can use them, such as
   magit-section, transient, and forge.

   #+CAPTION: (and Bufler Taxy Magit-Section) - www.reddit.com/r/emacs/comments/pkuwcq
   [[file:images/Screenshot_20211020_102147.png]]

   Here's an example of using magit-section to
   [[https://www.reddit.com/r/emacs/comments/pkuwcq/and_bufler_taxy_magitsection_a_concise_language/][manage groups of buffers]].

   #+CAPTION: Self-describing Smart DSLs - emacsconf.org/2021/talks/dsl/
   [[file:images/Screenshot_20211020_102242.png]]

   You can learn more about Transient
   in the talk on [[https://emacsconf.org/2021/talks/dsl/][self-describing 
   smart domain-specific languages]] or DSLs.
   
4. 
   #+CAPTION: 4. Completion - karthinks.com/software/avy-can-do-anything/
   [[file:images/minibuffer-interaction-paradigm.png]]
   In terms of smaller packages, there's been
   a lot of activity around completion.
   [[https://karthinks.com/software/avy-can-do-anything/][Karthik has a great diagram,]]
   #+CAPTION: Default Emacs completion and extras - https://protesilaos.com/codelog/2021-01-06-emacs-default-completion/
   [[file:images/Screenshot_20211024_165646.png]]
   [[https://protesilaos.com/codelog/2021-01-06-emacs-default-completion/][and Prot explains how things work together]].
   I think the idea is that instead of having
   one large completion system
   like Helm or Icicles, you can choose
   a few different, smaller packages
   and configure them to work together.
   If you're curious about this, 
   you might start with either
     
   #+CAPTION: selectrum - github.com/raxod502/selectrum
   [[file:images/Screenshot_20211020_204634.png]]
   [[https://github.com/raxod502/selectrum][selectrum]] 
   #+CAPTION: Vertico - github.com/minad/vertico
   [[file:images/vertico.svg]]
   or [[https://github.com/minad/vertico][vertico]],
   which are both completion interfaces,

   #+CAPTION: marginalia - github.com/minad/marginalia
   [[file:images/Screenshot_20211020_212130.png]]
   add [[https://github.com/minad/marginalia][marginalia]] for more information,

   #+CAPTION: consult - github.com/minad/consult
   [[file:images/consult-grep.gif]]
   and try [[https://github.com/minad/consult][consult]] for many useful
   completing commands.

   #+CAPTION: On completion frameworks - www.reddit.com/r/emacs/comments/ppg98f
   [[file:images/Screenshot_20211020_212308.png]]

   There are so many options, 
   so it might be useful to check out
   [[https://www.reddit.com/r/emacs/comments/ppg98f/which_completion_framework_do_you_use_and_why/][some discussions]].
5. 
   #+CAPTION: 5. Embark - github.com/oantolin/embark
   [[file:images/Screenshot_20211020_212456.png]]
   [[https://github.com/oantolin/embark][Embark]] is usually mentioned as part of  
   that group of packages, 
   but it's well worth looking into
   even if you use a different system. 
   Embark lets you have context-sensitive shortcuts
   that work on things in buffers, minibuffer content,
   and even collections of things.
   You can also use it
   when you start doing one command
   and then decide to do a different one instead.
   #+CAPTION: Fifteen ways to use Embark - karthinks.com/software/fifteen-ways-to-use-embark/
   [[file:images/Screenshot_20211020_212529.png]]
   For more ideas, check out 
   [[https://karthinks.com/software/fifteen-ways-to-use-embark/][Fifteen Ways to Use Embark]].
   
6. 
   #+CAPTION: Tree-sitter-powered editing - https://emacsconf.org/2021/talks/structural/
   [[file:images/Screenshot_20211022_171008.png]]
   Now that there are Emacs Lisp bindings 
   for tree-sitter, we can work more easily
   with the structure of code instead of 
   just using regular expressions.
   Check out the talk
   on [[https://emacsconf.org/2021/talks/structural/][Tree-edit and structural editing]]
   to learn more.
   #+CAPTION: 6. tree-sitter-powered Emacs Lisp - blog.meain.io/2021/intelligent-snippets-treesitter/
   [[file:images/Screenshot_20211020_212756.png]]
   You can use tree-sitter for
   [[https://blog.meain.io/2021/intelligent-snippets-treesitter/][intelligent snippets]] that get information 
   from the code around them,
   #+CAPTION: github.com/polaris64/symex-ts
   [[file:images/Screenshot_20211020_213017.png]]
   [[https://github.com/polaris64/symex-ts][editing Lisp expressions]], 
   #+CAPTION: github.com/meain/evil-textobj-tree-sitter
   [[file:images/evil-textobj.gif]]
   and [[https://github.com/meain/evil-textobj-tree-sitter][navigating text objects in Evil mode.]] 
   (That's when Emacs is pretending to be Vi.) 
   Dynamic modules help us add more to Emacs 
   than Emacs Lisp easily offers,
   #+CAPTION: GopCaml - www.youtube.com/watch?v=KipRuiLXYEo
   [[file:images/Screenshot_20211020_213235.png]]
   such as [[https://www.youtube.com/watch?v=KipRuiLXYEo][structural editing in OCaml]]
   #+CAPTION: parinfer-rust - github.com/justinbarclay/parinfer-rust-mode
   [[file:images/parinfer-rust.gif]]
   and [[https://github.com/justinbarclay/parinfer-rust-mode#installing][using Rust to figure out parentheses]]
   and indentation for Lisp.
   #+CAPTION: Extending Emacs in Rust with Dynamic Modules - emacsconf.org/2021/talks/rust/
   [[file:images/Screenshot_20211020_213423.png]]
   If you're curious about dynamic modules,
   check out the talk on
   [[https://emacsconf.org/2021/talks/rust/][Extending Emacs in Rust with Dynamic Modules]].
7. 
   #+CAPTION: 7. CRDT - collaborative editing - elpa.gnu.org/packages/crdt.html
   [[file:images/Screenshot_20211020_213543.png]]
   Collaborative editing is now much easier 
   since the [[https://elpa.gnu.org/packages/crdt.html][CRDT]] package is in GNU ELPA. ([[https://www.reddit.com/r/emacs/comments/pdi08v/crdtel_the_collaborative_editing_package_now_on/][Reddit]]) 
   It allows multiple people to edit 
   the same file over the network, 
   using their own Emacs. 
   This means you can keep your own config
   and keybindings, yay! 
   #+CAPTION: Emacs Research Group - emacsconf.org/2021/talks/erg/
   [[file:images/Screenshot_20211020_213619.png]]
   Watch the [[https://emacsconf.org/2021/talks/erg/][Emacs Research Group talk]] 
   for an example of how several people 
   used it to work together.
8.
   #+CAPTION: 8. More graphical experiments: OpenGL - www.reddit.com/r/emacs/comments/kn3fzq
   [[file:images/opengl.png]]
   In case you're still under the impression 
   that Emacs is just a text editor, 
   some folks have been working on 
   pretty neat graphical experiments.
   These [[https://www.reddit.com/r/emacs/comments/kn3fzq/draw_anything_to_emacs_buffers_with_opengl/][OpenGL bindings for Emacs Lisp]] 
   use an embedded xwidget,
   while other prototypes use the SVG support
   that's built into Emacs
   #+CAPTION: Gantt charts - github.com/Aightech/org-gantt-svg
   [[file:images/Screenshot_20211020_214059.png]]
   for [[https://github.com/Aightech/org-gantt-svg][Gantt charts]] ([[https://www.reddit.com/r/emacs/comments/prezj6/simple_gantt_chart_from_an_org_todo_list_with_svg/][Reddit]]),

   #+CAPTION: Scribble - lifeofpenguin.blogspot.com/2021/08/scribble-notes-in-gnu-emacs.html
   [[file:images/scribble.png]]
   [[https://lifeofpenguin.blogspot.com/2021/08/scribble-notes-in-gnu-emacs.html][scribbles]],
   #+CAPTION: el-easydraw - www.reddit.com/r/emacs/comments/pvtbq5
   [[file:images/Screenshot_20211020_214428.png]]
   and even [[https://www.reddit.com/r/emacs/comments/pvtbq5/emacs_drawing_tool/][diagrams]]. ([[https://www.reddit.com/r/emacs/comments/pvtbq5][Reddit]])
   #+CAPTION: el-easydraw color picker - github.com/misohena/el-easydraw
   [[file:images/color-picker-minibuffer.png]]
   The color-picker from that one 
   looks particularly useful for CSS.
   If you want to play around with adding SVGs 
   to your files and interfaces,
   #+CAPTION: svg-icon - github.com/rougier/emacs-svg-icon
   [[file:images/svg-icons.png]]
   [[https://github.com/rougier/emacs-svg-icon][svg icon]]
   #+CAPTION: svg-lib - elpa.gnu.org/packages/svg-lib.html
   [[file:images/svg-lib.png]]
   and [[https://elpa.gnu.org/packages/svg-lib.html][svg-lib]] 
   might be good places to start. ([[https://www.reddit.com/r/emacs/comments/pyee44/svglib_is_on_elpa/][Reddit]])
   Of course, there's always a place 
   for ASCII art,
   #+CAPTION: boxy-headings - www.reddit.com/r/emacs/comments/q2z29f
   [[file:images/boxy-headings.gif]]
   especially with the new [[https://gitlab.com/tygrdev/boxy][boxy]] package
   that you can use for [[https://www.reddit.com/r/emacs/comments/q2z29f/boxyheadlines_and_orgreal_are_now_on_elpa/][org files]],
   #+CAPTION: boxy-imenu - gitlab.com/tygrdev/boxy-imenu
   [[file:images/boxy-imenu.gif]]
   [[https://gitlab.com/tygrdev/boxy-imenu][imenu navigation]],
   #+CAPTION: org-real - gitlab.com/tygrdev/org-real
   [[file:images/org-real.gif]]
   and even [[https://gitlab.com/tygrdev/org-real][things in real life]].
9. 
   #+CAPTION: 9. Lots of posts and videos: System Crafters... - systemcrafters.cc/
   [[file:images/Screenshot_20211021_002413.png]]
   There have been a lot of great posts, videos 
   and livestreams about Emacs this year.
   In addition to the ones from [[https://systemcrafters.cc/][System Crafters]],
   #+CAPTION: Emacs Elements... - www.youtube.com/channel/UCe5excZqMeG1CIW-YhMTCEQ
   [[file:images/Screenshot_20211021_002120.png]]
   [[https://www.youtube.com/channel/UCe5excZqMeG1CIW-YhMTCEQ][Emacs Elements]],
   #+CAPTION: Protesilaos Stavrou... - protesilaos.com/
   [[file:images/Screenshot_20211021_002254.png]]
   and [[https://protesilaos.com/][Protesilaos]] 
   (who has started livestreaming),
   #+CAPTION: John Kitchin... - www.youtube.com/user/jrkitchin
   [[file:images/Screenshot_20211021_002218.png]]
   [[https://www.youtube.com/user/jrkitchin][John Kitchin]]
   #+CAPTION: Mike Zamansky - cestlaz.github.io/categories/emacs/
   [[file:images/Screenshot_20211021_002452.png]]
   and [[https://cestlaz.github.io/categories/emacs/][Mike Zamansky]] 
   are both back, hooray!
10. 
    #+CAPTION: 10. #emacs on libera.chat - www.emacswiki.org/emacs/EmacsChannel
    [[file:images/Screenshot_20211021_002604.png]]
    Lastly, if you want to chat 
    with other Emacs folks
    and get help on Emacs, Org Mode, 
    or other topics, the #emacs and #org-mode
    Internet Relay Chat or IRC channels
    are now on the [[https://libera.chat]] network
    instead of Freenode. ([[https://www.emacswiki.org/emacs/EmacsChannel][EmacsWiki]])

#+CAPTION: Emacs News Highlights - emacsconf.org/2021/talks/news
[[file:images/Screenshot_20211021_002952.png]]

If you'd like to add something I've missed,
please add them to the collaborative pad
if you're watching this live, 
add them to the wiki page, 
or e-mail me at [[mailto:sacha@sachachua.com][sacha@sachachua.com]] . 
That's all for this quick review. 
Enjoy the rest of EmacsConf 2021!

* Just the text
#+begin_src emacs-lisp
(save-excursion
  (goto-char (org-find-exact-headline-in-buffer "Talk plans"))
  (org-end-of-meta-data)
  (replace-regexp-in-string
   "\\[\\[http.*?\\]\\[\\(\\([^]]+\\|\n\\)*?\\)\\]\\]"
   "\\2"
   (replace-regexp-in-string "\n[ \t\n]*\n" "\n"
                             (buffer-substring-no-properties
                              (point) 
                              (org-end-of-subtree)))))

#+end_src

#+RESULTS:
:results:

#+CAPTION: Emacs News Highlights - emacsconf.org/2021/talks/news
[[file:images/Screenshot_20211021_002952.png]] 
I'm Sacha Chua, and here are 
ten Emacs News highlights for 2021.
If you want to follow the links,
check out the wiki page at
https://emacsconf.org/2021/talks/news/ .
#+CAPTION: 1. Emacs NEWS.28 - git.savannah.gnu.org/cgit/emacs.git/tree/etc/NEWS.28
[[file:images/Screenshot_20211020_095333.png]]
1. The Emacs developers are currently
   working on Emacs 28.1,
   which will be the next major release.
   #+CAPTION: Native compilation featured on System Crafters, www.youtube.com/watch?v=i8OLg-f9EHk
   [[file:images/Screenshot_20211020_095812.png]]
   Native compilation should
   make everything way faster,
   #+CAPTION: Emoji support
   [[file:images/EmacslZhRzr.svg]]
   and emoji support will probably
   make things more fun. üòéüëç
   John Wiegley will share more Emacs 28 details
   in his update, so check out his talk.
2.
   #+CAPTION: 2. Org Mode 9.5 - orgmode.org/Changes.html
   [[file:images/Screenshot_20211020_100623.png]]
   Org Mode is now at version 9.5.
   New features include
   a library for managing citations,
   #+CAPTION: asynchronous session support in Python - blog.tecosaur.com/tmio/2021-05-31-async.html
   [[file:images/org-async-python-demo.mp4]]
   asynchronous session support
   for code blocks,
   #+CAPTION: New faces for agenda - orgmode.org/Changes.html
   [[file:images/Screenshot_20211020_101636.png]]
   and better control
   of your agenda's appearance.
   #+CAPTION: Org Mode 9.5 - orgmode.org/Changes.html
   [[file:images/Screenshot_20211020_100623.png]]
   If you've been getting your Org packages
   from Org ELPA,
   you can update your configuration
   to get Org from GNU ELPA
   and org-contrib from NonGNU ELPA.
   #+CAPTION: Org Roam v2 - blog.jethro.dev/posts/org_roam_v2/
   [[file:images/Screenshot_20211020_101756.png]]
   The new release of the Org Roam package (TMIO)
   should be a faster and more consistent way
   to use Org to manage a knowledgebase,
   #+CAPTION: Org Roam UI - github.com/org-roam/org-roam-ui/
   [[file:images/org-roam-ui.png]]
   and org-roam-ui looks pretty snazzy.
   #+CAPTION: blog.tecosaur.com/tmio
   [[file:images/Screenshot_20211020_101922.png]]
   The best way to keep up with Org changes
   is to check out the blog This Month in Org.
3.
   #+CAPTION: 3. Magit 3 - emacsair.me/2021/05/25/magit-3.0/
   [[file:images/Screenshot_20211020_102028.png]]
   New Magit major release!
   Jonas Bernoulli has split some functionality
   into other packages so that
   Emacs Lisp developers can use them, such as
   magit-section, transient, and forge.
   #+CAPTION: (and Bufler Taxy Magit-Section) - www.reddit.com/r/emacs/comments/pkuwcq
   [[file:images/Screenshot_20211020_102147.png]]
   Here's an example of using magit-section to
   manage groups of buffers.
   #+CAPTION: Self-describing Smart DSLs - emacsconf.org/2021/talks/dsl/
   [[file:images/Screenshot_20211020_102242.png]]
   You can learn more about Transient
   in the talk on self-describing 
   smart domain-specific languages or DSLs.
4. 
   #+CAPTION: 4. Completion - karthinks.com/software/avy-can-do-anything/
   [[file:images/minibuffer-interaction-paradigm.png]]
   In terms of smaller packages, there's been
   a lot of activity around completion.
   Karthik has a great diagram,
   #+CAPTION: Default Emacs completion and extras - https://protesilaos.com/codelog/2021-01-06-emacs-default-completion/
   [[file:images/Screenshot_20211024_165646.png]]
   and Prot explains how things work together.
   I think the idea is that instead of having
   one large completion system
   like Helm or Icicles, you can choose
   a few different, smaller packages
   and configure them to work together.
   If you're curious about this, 
   you might start with either
   #+CAPTION: selectrum - github.com/raxod502/selectrum
   [[file:images/Screenshot_20211020_204634.png]]
   selectrum 
   #+CAPTION: Vertico - github.com/minad/vertico
   [[file:images/vertico.svg]]
   or vertico,
   which are both completion interfaces,
   #+CAPTION: marginalia - github.com/minad/marginalia
   [[file:images/Screenshot_20211020_212130.png]]
   add marginalia for more information,
   #+CAPTION: consult - github.com/minad/consult
   [[file:images/consult-grep.gif]]
   and try consult for many useful
   completing commands.
   #+CAPTION: On completion frameworks - www.reddit.com/r/emacs/comments/ppg98f
   [[file:images/Screenshot_20211020_212308.png]]
   There are so many options, 
   so it might be useful to check out
   some discussions.
5. 
   #+CAPTION: 5. Embark - github.com/oantolin/embark
   [[file:images/Screenshot_20211020_212456.png]]
   Embark is usually mentioned as part of  
   that group of packages, 
   but it's well worth looking into
   even if you use a different system. 
   Embark lets you have context-sensitive shortcuts
   that work on things in buffers, minibuffer content,
   and even collections of things.
   You can also use it
   when you start doing one command
   and then decide to do a different one instead.
   #+CAPTION: Fifteen ways to use Embark - karthinks.com/software/fifteen-ways-to-use-embark/
   [[file:images/Screenshot_20211020_212529.png]]
   For more ideas, check out 
   Fifteen Ways to Use Embark.
6. 
   #+CAPTION: Tree-sitter-powered editing - https://emacsconf.org/2021/talks/structural/
   [[file:images/Screenshot_20211022_171008.png]]
   Now that there are Emacs Lisp bindings 
   for tree-sitter, we can work more easily
   with the structure of code instead of 
   just using regular expressions.
   Check out the talk
   on Tree-edit and structural editing
   to learn more.
   #+CAPTION: 6. tree-sitter-powered Emacs Lisp - blog.meain.io/2021/intelligent-snippets-treesitter/
   [[file:images/Screenshot_20211020_212756.png]]
   You can use tree-sitter for
   intelligent snippets that get information 
   from the code around them,
   #+CAPTION: github.com/polaris64/symex-ts
   [[file:images/Screenshot_20211020_213017.png]]
   editing Lisp expressions, 
   #+CAPTION: github.com/meain/evil-textobj-tree-sitter
   [[file:images/evil-textobj.gif]]
   and navigating text objects in Evil mode. 
   (That's when Emacs is pretending to be Vi.) 
   Dynamic modules help us add more to Emacs 
   than Emacs Lisp easily offers,
   #+CAPTION: GopCaml - www.youtube.com/watch?v=KipRuiLXYEo
   [[file:images/Screenshot_20211020_213235.png]]
   such as structural editing in OCaml
   #+CAPTION: parinfer-rust - github.com/justinbarclay/parinfer-rust-mode
   [[file:images/parinfer-rust.gif]]
   and using Rust to figure out parentheses
   and indentation for Lisp.
   #+CAPTION: Extending Emacs in Rust with Dynamic Modules - emacsconf.org/2021/talks/rust/
   [[file:images/Screenshot_20211020_213423.png]]
   If you're curious about dynamic modules,
   check out the talk on
   Extending Emacs in Rust with Dynamic Modules.
7. 
   #+CAPTION: 7. CRDT - collaborative editing - elpa.gnu.org/packages/crdt.html
   [[file:images/Screenshot_20211020_213543.png]]
   Collaborative editing is now much easier 
   since the CRDT package is in GNU ELPA. (Reddit) 
   It allows multiple people to edit 
   the same file over the network, 
   using their own Emacs. 
   This means you can keep your own config
   and keybindings, yay! 
   #+CAPTION: Emacs Research Group - emacsconf.org/2021/talks/erg/
   [[file:images/Screenshot_20211020_213619.png]]
   Watch the Emacs Research Group talk 
   for an example of how several people 
   used it to work together.
8.
   #+CAPTION: 8. More graphical experiments: OpenGL - www.reddit.com/r/emacs/comments/kn3fzq
   [[file:images/opengl.png]]
   In case you're still under the impression 
   that Emacs is just a text editor, 
   some folks have been working on 
   pretty neat graphical experiments.
   These OpenGL bindings for Emacs Lisp 
   use an embedded xwidget,
   while other prototypes use the SVG support
   that's built into Emacs
   #+CAPTION: Gantt charts - github.com/Aightech/org-gantt-svg
   [[file:images/Screenshot_20211020_214059.png]]
   for Gantt charts (Reddit),
   #+CAPTION: Scribble - lifeofpenguin.blogspot.com/2021/08/scribble-notes-in-gnu-emacs.html
   [[file:images/scribble.png]]
   scribbles,
   #+CAPTION: el-easydraw - www.reddit.com/r/emacs/comments/pvtbq5
   [[file:images/Screenshot_20211020_214428.png]]
   and even diagrams. (Reddit)
   #+CAPTION: el-easydraw color picker - github.com/misohena/el-easydraw
   [[file:images/color-picker-minibuffer.png]]
   The color-picker from that one 
   looks particularly useful for CSS.
   If you want to play around with adding SVGs 
   to your files and interfaces,
   #+CAPTION: svg-icon - github.com/rougier/emacs-svg-icon
   [[file:images/svg-icons.png]]
   svg icon
   #+CAPTION: svg-lib - elpa.gnu.org/packages/svg-lib.html
   [[file:images/svg-lib.png]]
   and svg-lib 
   might be good places to start. (Reddit)
   Of course, there's always a place 
   for ASCII art,
   #+CAPTION: boxy-headings - www.reddit.com/r/emacs/comments/q2z29f
   [[file:images/boxy-headings.gif]]
   especially with the new boxy package
   that you can use for org files,
   #+CAPTION: boxy-imenu - gitlab.com/tygrdev/boxy-imenu
   [[file:images/boxy-imenu.gif]]
   imenu navigation,
   #+CAPTION: org-real - gitlab.com/tygrdev/org-real
   [[file:images/org-real.gif]]
   and even things in real life.
9. 
   #+CAPTION: 9. Lots of posts and videos: System Crafters... - systemcrafters.cc/
   [[file:images/Screenshot_20211021_002413.png]]
   There have been a lot of great posts, videos 
   and livestreams about Emacs this year.
   In addition to the ones from System Crafters,
   #+CAPTION: Emacs Elements... - www.youtube.com/channel/UCe5excZqMeG1CIW-YhMTCEQ
   [[file:images/Screenshot_20211021_002120.png]]
   Emacs Elements,
   #+CAPTION: Protesilaos Stavrou... - protesilaos.com/
   [[file:images/Screenshot_20211021_002254.png]]
   and Protesilaos 
   (who has started livestreaming),
   #+CAPTION: John Kitchin... - www.youtube.com/user/jrkitchin
   [[file:images/Screenshot_20211021_002218.png]]
   John Kitchin
   #+CAPTION: Mike Zamansky - cestlaz.github.io/categories/emacs/
   [[file:images/Screenshot_20211021_002452.png]]
   and Mike Zamansky 
   are both back, hooray!
10. 
    #+CAPTION: 10. #emacs on libera.chat - www.emacswiki.org/emacs/EmacsChannel
    [[file:images/Screenshot_20211021_002604.png]]
    Lastly, if you want to chat 
    with other Emacs folks
    and get help on Emacs, Org Mode, 
    or other topics, the #emacs and #org-mode
    Internet Relay Chat or IRC channels
    are now on the [[https://libera.chat]] network
    instead of Freenode. (EmacsWiki)
#+CAPTION: Emacs News Highlights - emacsconf.org/2021/talks/news
[[file:images/Screenshot_20211021_002952.png]]
If you'd like to add something I've missed,
please add them to the collaborative pad
if you're watching this live, 
add them to the wiki page, 
or e-mail me at [[mailto:sacha@sachachua.com][sacha@sachachua.com]] . 
That's all for this quick review. 
Enjoy the rest of EmacsConf 2021!
:end:


* Tasks and ideas
** WAITING Coordinate with johnw
:LOGBOOK:
- State "WAITING"    from "TODO"       [2021-10-20 Wed 09:48] \\
  Waiting for update
:END:
** DONE Record audio
CLOSED: [2021-10-20 Wed 09:48]
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-10-20 Wed 09:48]
:END:
** DONE Collect visuals
CLOSED: [2021-10-21 Thu 00:38]
:PROPERTIES:
:Effort:   1:00
:QUANTIFIED: Emacs
:END:
:LOGBOOK:
- State "DONE"       from "STARTED"    [2021-10-21 Thu 00:38]
CLOCK: [2021-10-20 Wed 09:48]
:END:
** DONE Rerecord audio
CLOSED: [2021-10-24 Sun 02:25]
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-10-24 Sun 02:25]
:END:
** CANCELLED Merge audio from different files
CLOSED: [2021-10-24 Sun 02:25]
** DONE Figure out how to stitch visuals together
CLOSED: [2021-10-22 Fri 17:14]
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-10-22 Fri 17:14]
:END:

ffmpeg?

#+begin_src emacs-lisp

#+end_src

#+RESULTS:
:results:
nil
:end:

Actually, I'd like to get these out of the vtt as well, so I can determine timing.

#+begin_src emacs-lisp
(defmacro my-talk-with-script (&rest body)
  (declare (debug t))
  `(with-current-buffer my-record-script-buffer
     (save-restriction
       (save-excursion
         (goto-char (org-find-exact-headline-in-buffer my-talk-script-heading))
         (narrow-to-region (save-excursion (org-end-of-meta-data) (point)) (save-excursion (org-end-of-subtree)))
         ,@body))))

(defun my-record-segment-get-video-duration-ms (filename)
  (* 1000
     (string-to-number
      (shell-command-to-string
       (concat "ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "
               (shell-quote-argument (expand-file-name filename)))))))

(defun my-record-segment-get-frames (filename)
  (string-to-number
   (shell-command-to-string
    (concat "ffprobe -v error -select_streams v:0 -count_packets -show_entries stream=nb_read_packets -of csv=p=0 "
            (shell-quote-argument (expand-file-name filename))))))

(defvar my-record-description-height 50 "Number of pixels for top description in video.")
(defvar my-record-caption-height 150 "Number of pixels to leave at the bottom for captions in video.")
(defvar my-record-output-video-width 1280)
(defvar my-record-output-video-height 720)
(defun my-record-segment-scale-filter (o)
  "Return the complex filter for scaling."
  (seq-let (start-ms end-ms caption description) o
    (format "scale=%d:%d:force_original_aspect_ratio=decrease,setsar=sar=1,pad=%d:%d:(ow-iw)/2:%d+(oh-%d-%d-ih)/2"
            my-record-output-video-width
            (- my-record-output-video-height (or my-record-caption-height 0) (or my-record-description-height 0))
            my-record-output-video-width
            my-record-output-video-height
            my-record-description-height
            my-record-description-height
            my-record-caption-height
            )))

(defvar my-record-description-drawtext-filter-params "fontcolor=white:x=5:y=5:fontsize=40:font=sachacHand")
(defun my-record-format-selection-as-visuals (selection)
  (let* (info)
    (setq info
          (seq-map-indexed
           (lambda (o i)
             (seq-let (start-ms end-ms caption description description-filter) o
               (setq description-filter
                     (if description
                         (concat ",drawtext=\"" my-record-description-drawtext-filter-params ":text='"
                                 description ; TODO quote this properly
                                 "'\"")
                       ""))
               (when (string-match "file:\\([^]]+\\)" caption)
                 (let* ((filename (match-string 1 caption))
                        (duration (- end-ms start-ms))
                        (scale (my-record-segment-scale-filter o)))
                   (cond
                    ((string-match "mp4" caption)
                     (list
                      (format "-i %s" filename)
                      (let ((video-duration (my-record-segment-get-video-duration-ms filename)))
                        (format
                         "[%d:v]setpts=PTS*%.3f,%s%s[r%d];"
                         i
                         (/ duration video-duration)
                         scale
                         description-filter
                         i))))
                    ((string-match "gif$" filename)
                     (let ((gif-frames (my-record-segment-get-frames filename)))
                       (list
                        (format "-r %0.3f -i %s" (/ gif-frames (/ duration 1000.0)) filename)
                        ;; (format "-i %s" filename)
                        (format "[%d:v]%s%s[r%d];" i scale description-filter i))))
                    (t
                     (list
                      (format "-loop 1 -t %0.3f -i %s"
                              (/ duration 1000.0)
                              (shell-quote-argument filename))
                      (format "[%d:v]%s%s[r%d];" i scale description-filter i))))))))
           selection))
    (concat
     (mapconcat 'car info " ")
     " -filter_complex \""
     (mapconcat 'cadr info "")
     (mapconcat
      (lambda (o) (format "[r%d]" o))
      (number-sequence 0 (1- (length selection)))
      "")
     (format "concat=n=%d:v=1:a=0\"" (length selection)))))
(defvar my-record-segments-buffer "*Segments*" "Buffer with the segments.")
(defun my-record-compile-visuals ()
  (interactive)
  (let ((result
         (concat "ffmpeg -y "
                 (with-current-buffer my-record-segments-buffer
                   (my-record-format-selection-as-visuals (my-record-get-selection-for-region (point-min) (point-max))))
                 " -shortest -c:v vp8 -vsync 1 -b:v 800k visuals.webm")))
    (kill-new result)
    result))
(defun my-record-test-visuals (&optional limit)
  (interactive "p")
  (let* ((visuals (my-talk-with-script
                   (cl-loop
                    while (re-search-forward "#\\+CAPTION: \\(.+\\)\n[ \t]*\\(\\[\\[file:[^]]+\\]\\)" nil t)
                    collect (list 1000 2000
                                  (match-string-no-properties 2)
                                  (match-string-no-properties 1)
                                  ))))
         (result
          (concat "ffmpeg -y "
                  (with-current-buffer my-record-segments-buffer
                    (my-record-format-selection-as-visuals
                     (if (> limit 1)
                         (seq-take visuals limit)
                       visuals)
                     ))
                  " -i visuals.vtt -c:v vp8 -vsync 2 -b:v 800k visuals.webm")))
    (kill-new result)
    result))
#+end_src

#+RESULTS:
:results:
my-record-test-visuals
:end:
*** DONE handle animated gifs
CLOSED: [2021-10-22 Fri 17:14]
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-10-22 Fri 17:14]
:END:
https://unix.stackexchange.com/questions/40638/how-to-do-i-convert-an-animated-gif-to-an-mp4-or-mv4-on-the-command-line
*** DONE squeeze videos to fit
CLOSED: [2021-10-22 Fri 17:14]
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-10-22 Fri 17:14]
:END:
** DONE Figure out what to do about resolution
CLOSED: [2021-10-22 Fri 17:15]
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-10-22 Fri 17:15]
:END:
1366x768,
wanted 1280x720,
my images are small

Oh, just needed bitrate

** CANCELLED Tweak audio editing so that I can bisect the start or end given an offset
CLOSED: [2021-10-24 Sun 02:25]
#+begin_src emacs-lisp

#+end_src

#+RESULTS:
:results:
nil
:end:

** DONE Tweak caption timing and include it
CLOSED: [2021-10-24 Sun 02:25]
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-10-24 Sun 02:25]
:END:
** TODO Figure out the visual timing
** TODO Put everything together and send the video
** SOMEDAY Change the waveform to slice a larger image?
:PROPERTIES:
:CREATED:  [2021-10-25 Mon 02:25]
:END:

https://trac.ffmpeg.org/wiki/Seeking#Cuttingsmallsections
Check if I'm seeking accurately enough for the waveform

https://emacs.stackexchange.com/questions/7682/get-width-of-an-image

*** SOMEDAY How to get time stamp of closest keyframe before a given timestamp with FFmpeg? - Super User
:PROPERTIES:
:CREATED:  [2021-10-25 Mon 09:44]
:END:

https://superuser.com/questions/554620/how-to-get-time-stamp-of-closest-keyframe-before-a-given-timestamp-with-ffmpeg

*** SOMEDAY How to specify the portion of the image to be rendered inside SVG:image tag? - Stack Overflow
:PROPERTIES:
:CREATED:  [2021-10-25 Mon 12:37]
:END:

https://stackoverflow.com/questions/16983442/how-to-specify-the-portion-of-the-image-to-be-rendered-inside-svgimage-tag
** SOMEDAY Display timestamp as I move the mouse
https://emacs.stackexchange.com/questions/51482/how-to-perform-interactive-auto-scroll
*** SOMEDAY How to display a message in echo-area only - Emacs Stack Exchange
:PROPERTIES:
:CREATED:  [2021-10-24 Sun 21:10]
:END:

https://emacs.stackexchange.com/questions/3116/how-to-display-a-message-in-echo-area-only

*** SOMEDAY https://www.gnu.org/software/emacs/manual/html_node/elisp/Mouse-Tracking.html
:PROPERTIES:
:CREATED:  [2021-10-24 Sun 21:37]
:END:

** SOMEDAY Pop up waveform, bisect
:PROPERTIES:
:CREATED:  [2021-10-22 Fri 16:31]
:END:

#+begin_src emacs-lisp


(defun my-subed-bisect-start (offset)
  (interactive (list 2))
  (setq offset (* 1000 offset))
  (let* ((start (subed-subtitle-msecs-start))
         (pos (- start (/ offset 2.0)))
         ch
         done)
    (while (not done)
      (subed-mpv-jump pos)
      (subed-mpv-unpause)
      (setq ch (read-key (format "%s %f 1: back, 2: repeat, 3: accept, 4: forward, q: cancel" (my-msecs-to-timestamp pos) offset)))
      (pcase ch
        (?1 (setq offset (/ offset 2) pos (- pos offset)))
        (?4 (setq offset (/ offset 2) pos (+ pos offset)))
        (?2 (subed-mpv-jump pos))
        (?3 (setq done t))
        (?q (setq pos nil done t))
        )
      )
    (if pos
        (subed-set-subtitle-time-start pos))
    (subed-mpv-pause)))
(defun my-subed-yank-mpv-timestamp ()
  (interactive)
  (let ((time (subed-msecs-to-timestamp subed-mpv-playback-position)))
    (kill-new time)
    (message "%s" time)))

#+end_src

#+RESULTS:
:results:
my-subed-yank-mpv-timestamp
:end:

** SOMEDAY Maybe svg with embedded image? https://www.gnu.org/software/emacs/manual/html_node/elisp/SVG-Images.html
:PROPERTIES:
:CREATED:  [2021-10-22 Fri 18:18]
:END:

Then I can move the line

** SOMEDAY Add svg bars for the waveform subtitles
:PROPERTIES:
:CREATED:  [2021-10-23 Sat 17:40]
:END:

** SOMEDAY Show Link Tooltip mouse over with keystroke - Emacs Stack Exchange
:PROPERTIES:
:CREATED:  [2021-10-23 Sat 18:30]
:END:

https://emacs.stackexchange.com/questions/43930/show-link-tooltip-mouse-over-with-keystroke

Show tooltip with time, caption text

** SOMEDAY https://www.gnu.org/software/emacs/manual/html_node/elisp/Window-Hooks.html
:PROPERTIES:
:CREATED:  [2021-10-23 Sat 21:26]
:END:

** SOMEDAY ffmpeg: How to keep audio synced when doing many (100) cuts with filter select='between(t,start,stop)+between...' - Stack Overflow
:PROPERTIES:
:CREATED:  [2021-10-23 Sat 21:34]
:END:

https://stackoverflow.com/questions/66052977/ffmpeg-how-to-keep-audio-synced-when-doing-many-100-cuts-with-filter-select

** SOMEDAY How to extract time-accurate video segments with ffmpeg? - Stack Overflow
:PROPERTIES:
:CREATED:  [2021-10-23 Sat 21:36]
:END:

https://stackoverflow.com/questions/21420296/how-to-extract-time-accurate-video-segments-with-ffmpeg
** SOMEDAY Display waveforms and select
:PROPERTIES:
:CREATED:  [2021-10-20 Wed 09:42]
:END:

** SOMEDAY Try ffmpeg concat inpoint outpoint, instead of aselect?
:PROPERTIES:
:CREATED:  [2021-10-23 Sat 23:21]
:END:

** SOMEDAY FFmpeg concat demuxer cuts are wildly inacurate, even for raw audio - Super User
:PROPERTIES:
:CREATED:  [2021-10-23 Sat 23:22]
:END:

https://superuser.com/questions/1434168/ffmpeg-concat-demuxer-cuts-are-wildly-inacurate-even-for-raw-audio

* Code
** STARTED Recording tool
:PROPERTIES:
:CREATED:  [2021-10-19 Tue 21:07]
:Effort:   1:00
:QUANTIFIED: Emacs
:END:
:LOGBOOK:
CLOCK: [2021-10-19 Tue 23:03]
:END:

Goal:

Srt or vtt file with subtitle copies so that I can easily replay segments, delete the ones I don't want to keep, and then use ffmpeg to collapse it into a smooth audio track.

Interface:

#+begin_src emacs-lisp
(obs-websocket-connect)
#+end_src

#+RESULTS:
:results:
t
:end:

#+begin_src emacs-lisp
(defvar my-record-backend nil "Either 'sox, 'obs, or nil.")
(defvar my-record-frontend 'hydra "Either 'hydra or 'web.")
(defvar my-record-directory "tmp")
(defvar my-record-audio-extension ".ogg")
(defvar my-record-start nil "Start of the current recording segment in milliseconds.")
(defvar my-record-end nil "End of current recording sgement in milliseconds.")
(defvar my-record-caption nil "Current caption.")
(defvar my-record-paused nil "If non-nil, recording is currently paused.")

(defvar my-record-sox-process nil "Process for recording via sox.")
(defvar my-record-sox-buffer "*Sox*")
(defvar my-record-sox-executable "rec")
(defvar my-record-sox-channels 1)
(defvar my-record-sox-rate 48000)
(defvar my-record-start-time nil "Emacs timestamp from when the sox process was started.")
(defvar my-record-sox-filename nil)

(defun my-record-current-filename ()
  (cond
   ((eq my-record-backend 'obs) obs-websocket-recording-filename)
   ((eq my-record-backend 'sox) my-record-sox-filename)
   (t "")))
(defun my-record-offset-ms (&optional time)
  (cond
   ((eq my-record-backend 'obs) (my-obs-websocket-recording-time-msecs))
   (t (* (float-time (time-subtract (or time (current-time)) my-record-start-time)) 1000.0)))) ; sox or nil

(defun my-record-sox-start (&optional filename)
  (interactive)
  (setq my-record-sox-filename
        (or filename
            (expand-file-name
             (concat (format-time-string "%Y-%m-%d-%H%M%S") my-record-audio-extension)
             my-record-directory)))
  (setq my-record-sox-buffer
        (get-buffer-create my-record-sox-buffer))
  (if (process-live-p my-record-sox-process)
      (quit-process my-record-sox-process))
  (kill-new my-record-sox-filename)
  (setq my-record-sox-process
        (start-process
         "sox"
         my-record-sox-buffer
         my-record-sox-executable
         "-r"
         (number-to-string my-record-sox-rate)
         "-c"
         (number-to-string my-record-sox-channels)
         my-record-sox-filename))
  (setq my-record-start-time (current-time)))

(defun my-record-current-caption ()
  (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
(defun my-record-send-caption ()
  (setq my-record-caption (my-record-current-caption))
  (when (eq my-record-backend 'obs)
    (obs-websocket-send "SendCaptions" :text (string-trim (my-record-current-caption)))))
(defun my-record-set-start (&optional time)
  (setq my-record-start (my-record-offset-ms time)))
(defun my-record-cancel-segment (&optional time)
  "Reset the start of the current segment and ignore the previous recording."
  (interactive)
  (my-record-set-start time)
  (setq my-record-end nil)
  (my-record-send-caption))

(defun my-record-save-segment (&optional time)
  "Save the current segment in the target file."
  (when (and my-record-start (my-record-current-filename))
    (with-current-buffer (get-buffer-create my-record-segments-buffer)
      (goto-char (point-max))
      (setq my-record-end (or my-record-end (my-record-offset-ms time)))
      (insert "\n\nNOTE: " (my-record-current-filename) "\n"
              (my-msecs-to-timestamp my-record-start) " --> " (my-msecs-to-timestamp my-record-end) "\n"
              (string-trim my-record-caption) "\n")
      (setq my-record-end nil)
      (my-record-set-start time)
      (my-scroll-buffer-to-bottom (current-buffer)))))

(defun my-scroll-buffer-to-bottom (&optional buffer)
  "Scroll buffer to bottom in all its windows."
  (let ((windows (get-buffer-window-list (or buffer (current-buffer)) t t)))
    (dolist (window windows)
      (set-window-point window (point-max)))))

(defun my-record-retry-segment (&optional time)
  "Unpause if needed, copy segment to the other window, and set the beginning time."
  (interactive)
  (my-record-save-segment time)
  (my-record-set-start time)
  (my-record-send-caption))

;; RET Accept segment and move to next one: set end of segment, copy to other side, highlight next segment to say, unpause if needed
;; backspace Cancel segment: reset the start of the current segment, display feedback
;; Left arrow Retry segment: unpause if needed, copy segment to the other window, set beginning time
;; Space Pause recording: use this as the end time; pause recording
;; q Stop recording: accept current segment and then stop
;; Up, down Go to previous or next subtitle: 
;; Ins Edit: cancel segment, stop recording

(defun my-record-previous-segment (&optional time)
  "Cancel segment, set new beginning time, move forward."
  (interactive)
  (forward-line -1)
  (my-record-cancel-segment time))

(defun my-record-next-segment (&optional time)
  "Cancel segment, set new beginning time, move forward."
  (interactive)
  (forward-line 1)
  (my-record-cancel-segment time))

(defun my-record-stop (&optional time)
  "Finish recording."
  (interactive)
  (my-record-save-segment time)
  (cond
   ((eq my-record-backend 'sox)
    (when (process-live-p my-record-sox-process) (quit-process my-record-sox-process)))
   ((eq my-record-backend 'obs)
    (obs-websocket-send "StopRecording"))))

;; (defun my-record-pause ()
;;   "Toggle recording."
;;   (interactive)
;;   (if my-record-paused
;;       (obs-websocket-send "ResumeRecording")
;;     (obs-websocket-send "PauseRecording")
;;     (setq my-record-end (my-obs-websocket-recording-time-msecs)))
;;   (setq my-record-paused (null my-record-paused))
;;   nil)

;; (defun my-record-edit ()
;;   "SomeDocs"
;;   (interactive)
;;   nil)

(defun my-record-accept-segment (&optional time)
  "Accept segment and move to next one: set end of segment, copy to other side, highlight next segment to say."
  (interactive)
  (my-record-save-segment time)
  (forward-line 1)
  (my-record-send-caption))

(defun my-record-setup-windows ()
  (delete-other-windows)  
  (setq my-record-script-buffer (current-buffer))  
  (with-selected-window (split-window-right -40)
    (switch-to-buffer (get-buffer-create my-record-segments-buffer))
    ;; (with-selected-window (split-window-below -10)
    ;;   (switch-to-buffer (my-record-make-buttons)))
    )
  (if my-record-backend (text-scale-set 4)))
(defun my-record-setup ()
  (interactive)
  (my-record-start)
  (setq my-record-segments-buffer
        (find-file-noselect (expand-file-name
                             (concat (file-name-base (my-record-current-filename)) ".vtt")
                             my-record-directory)))
  (my-record-setup-windows)
  (setq my-record-start-time (current-time))
  (my-record-retry-segment)
  (my-record-body))

(defhydra my-record (:exit nil)
  ("SPC" my-stream-toggle-recording (format "Recording [%s]" (if obs-websocket-recording-p "X" " ")))
  ("RET" my-record-accept-segment "Accept")
  ("<backspace>" my-record-cancel-segment "Cancel")
  ("<left>" my-record-retry-segment "Retry")
  ("<up>" my-record-previous-segment "Previous")
  ("<down>" my-record-next-segment "Next")
  ("q" my-record-stop "Stop" :exit t)
  ;; ("SPC" my-record-pause "Pause")
  ;; ("<insert>" my-record-edit "Edit" :exit t)
  )

(defun my-record-make-buttons ()
  (interactive)
  (with-current-buffer (get-buffer-create "*Control*")
    (let ((inhibit-read-only t))
      (erase-buffer)
      (text-scale-set 6)
      (widget-create
       'push-button
       :notify (lambda (&rest ignore)
                 (with-current-buffer my-record-script-buffer
                   (my-record-previous-segment)
                   (set-window-point (selected-window) (point))))
       "Previous")
      (insert "\n")
      (widget-create
       'push-button
       :notify (lambda (&rest ignore) (with-current-buffer my-record-script-buffer (my-record-retry-segment)))
       "Retry")
      (insert "\n")
      (widget-create
       'push-button
       :notify (lambda (&rest ignore) (with-current-buffer my-record-script-buffer
                                        (my-record-accept-segment)
                                        (set-window-point (selected-window) (point))))
       "Accept")
      (widget-setup)
      (widget-minor-mode))
    (current-buffer)))

(defun my-record-start ()
  "Start recording."
  (interactive)
  (cond
   ((eq my-record-backend 'obs)
    (when (not (websocket-openp obs-websocket))
      (obs-websocket-connect))
    (obs-websocket-send "StartRecording"))
   ((eq my-record-backend 'sox) (my-record-sox-start))))

;; (defun my-record-select-line (event)
;;   (interactive "e")
;;   (my-record-save-segment)
;;   (let ((pos (elt (cadr event) 5)))
;;     (goto-char pos)
;;     (beginning-of-line)
;;     (my-record-send-caption)))
;; (defvar my-record-mode-map (make-sparse-keymap))
;; (defvar my-record-mode-map
;;   (let ((map (make-sparse-keymap)))
;;    (define-key map (kbd "SPC") #'my-stream-toggle-recording)
;;     (define-key map (kbd "RET") #'my-record-accept-segment)
;;     (define-key map (kbd "<backspace>") #' my-record-cancel-segment)
;;     (define-key map (kbd "<left>") #' my-record-retry-segment)
;;     (define-key map (kbd "<up>") #' my-record-previous-segment)
;;     (define-key map (kbd "<down>") #' my-record-next-segment)
;;     (define-key map "q" #'my-record-stop)
;;     (define-key map (kbd "C-c C-c") 'my-record-mode)
;;     map))

;; (define-minor-mode my-record-mode 
;;   "Record audio and associate with lines from the current file."
;;   nil
;;   :lighter "rec"
;;   :global nil
;;   :keymap my-record-mode-map
;;   (if my-record-mode
;;       (progn
;;         (message "Now recording..."))
;;     (message "Stopped recording.")))
#+end_src

#+RESULTS:
:results:
my-record-start
:end:

Let's try a subed-based version. Maybe that will be easier for me to manage.

#+begin_src emacs-lisp
(add-to-list 'subed-video-extensions "wav")
(defun my-record-subed-setup ()
  (interactive)
  (my-record-sox-start (concat (file-name-sans-extension (buffer-file-name)) my-record-audio-extension))
  (message "Recording...")
  (my-record-subed/body))

(defun my-record-subed-accept-segment ()
  (interactive)
  (let ((end-time (my-record-offset-ms)))
    (subed-set-subtitle-time-start my-record-start)
    (subed-set-subtitle-time-stop (my-record-offset-ms))
    (subed-forward-subtitle-text)
    (setq my-record-start (my-record-offset-ms))))
(defun my-record-subed-retry ()
  (interactive)
  (setq my-record-start (my-record-offset-ms)))

(defhydra my-record-subed (:exit nil)
  ("<up>" subed-backward-subtitle-text "Previous")
  ("<down>" my-record-subed-accept-segment "Accept")
  ("<left>" my-record-subed-retry "Retry")
  ("<right>" recenter-top-bottom)
  ("q" my-record-stop "Quit" :exit t)
  ("RET" my-record-stop "Quit" :exit t))

(defun my-subed-add-filenames-to-subtitles ()
  (interactive)
  (goto-char (point-min))
  (while (re-search-forward
          (concat
           "\\(NOTE: .*?\n\\)?\\(" subed-vtt--regexp-timestamp " \\-\\-> " subed-vtt--regexp-timestamp "\n\\)")
          nil t)
    (replace-match (concat "NOTE: " (subed-guess-video-file) "\n" (match-string 2)) t t nil 0)))
#+end_src
#+RESULTS:
:results:
my-record-subed/body
:end:

Split window; left side has the script, right has the notes I'm making
Vtt format
NOTE filename
Start end
Text

Start recording: start OBS recording
RET Accept segment and move to next one: set end of segment, copy to other side, highlight next segment to say, unpause if needed
backspace Cancel segment: reset the start of the current segment, display feedback
Left arrow Retry segment: unpause if needed, copy segment to the other window, set beginning time
Space Pause recording: use this as the end time; pause recording
q Stop recording: accept current segment and then stop
Up, down Go to previous or next subtitle: cancel segment, set new beginning time
Ins Edit: cancel segment, stop recording

And then afterwards, use subed to play back different options

And then write a tool that will take the vtt and spit out the right ffmpeg command to process the webm with a black screen, audio, and subtitles, and a vtt file that's also trimmed.

And then take the images and drop them in

#+begin_src emacs-lisp
(require 'subed-vtt)

(defun my-record-format-as-ffmpeg-selection (list)
  "LIST is a list of (start-ms end-ms text description filename)."
  (format "aselect='%s',asetpts='N/SR/TB'"
          (mapconcat
           (lambda (o)
             (format "between(t,%.3f,%.3f)"
                     (/ (plist-get o :start-ms) 1000.0)
                     (/ (plist-get o :stop-ms) 1000.0)))
           list
           "+")))

(defun my-record-format-as-audacity-labels (list)
  "LIST is a list of (start-ms end-ms text)."
  (mapconcat
   (lambda (o)
     (format "%0.3f\t%0.3f\t%s\n"
             (/ (plist-get o :start-ms) 1000.0)
             (/ (plist-get o :stop-ms) 1000.0)
             (string-trim (replace-regexp-in-string "[\t\n]+" " " (plist-get o :caption)))))
   list
   ""))

(defun my-record-format-as-vtt (list)
  (let ((ms 0))
    (concat "WEBVTT\n\n"
            (mapconcat
             (lambda (o)
               (prog1
                   (format "%s --> %s\n%s\n\n"
                           (my-msecs-to-timestamp ms)
                           (my-msecs-to-timestamp (+ ms (- (plist-get o :stop-ms)
                                                           (plist-get o :start-ms))))
                           (replace-regexp-in-string "#+CAPTION.*?\n\\|\\[[file.*?]]\n" ""
                                                     (plist-get o :caption) ))
                 (setq ms (+ ms (- (plist-get o :stop-ms)
                                   (plist-get o :start-ms))))))
             list
             ""))))

(defun my-subexp-num-at-point ()
  "Return the number of the subexp starting at point."
  (let ((limit (point))
        (count 0))
    (save-excursion
      (goto-char (my-beginning-of-font-lock-string))
      (while (re-search-forward "\\\\(" limit t)
        (unless (looking-at "\\\\(\\?:")
          (setq count (1+ count)))))
    (if (looking-at "\\\\(")
        (1+ count)
      count)))
(defun my-beginning-of-font-lock-string ()
  (let ((face (get-text-property (point) 'face))
        (val 'font-lock-string-face))
    (while (and (not (bobp))
                (if (listp face)
                    (member val face)
                  (eq val face)))
      (forward-char -1)
      (setq face (get-text-property (point) 'face)))
    (unless (if (listp face)
                (member val face)
              (eq val face))
      (forward-char 1))
    (point)))
(defun my-kill-match-string ()
  (kill-new (format "(match-string %d)" (my-subexp-num-at-point))))

(defun my-record-get-selection-for-region (beg end)
  (interactive "r")
  (goto-char beg)
  (let (result)
    (subed-for-each-subtitle beg end nil
      (let* ((caption (subed-subtitle-text))
             (start-ms (subed-subtitle-msecs-start))
             (end-ms (subed-subtitle-msecs-stop))
             description file)
        (when (string-match "#\\+CAPTION: \\(.+?\\)\n" caption)
          (setq description (match-string 1 caption))
          (setq caption (replace-match "" nil t caption)))
        (when (string-match "\\[\\[file:\\([^]]+?\\)\\].+\n" caption)
          (setq file (match-string 1 caption))
          (setq caption (replace-match "" nil t caption)))
        (if start-ms
            (setq result (cons 
                          (list :start-ms start-ms
                                :stop-ms end-ms
                                :caption caption
                                :visual-description description
                                :visual-file file
                                nil)
                          result)))))
    (reverse result)))

(defun my-record-export-labels (&optional beg end)
  (interactive "r")
  (with-temp-file
      (expand-file-name
       (concat
        (file-name-base (buffer-file-name (or my-record-segments-buffer (current-buffer))))
        ".txt")
       (file-name-directory (buffer-file-name (or my-record-segments-buffer (current-buffer)))))
    (insert (my-record-format-as-audacity-labels
             (with-current-buffer (or my-record-segments-buffer (current-buffer))
               (unless (region-active-p)
                 (setq beg (point-min) end (point-max)))
               (my-record-get-selection-for-region beg end)))))) 
(defvar my-record-recording nil "File to split up.")

(defun my-record-compose-audio (&optional beg end)
  (interactive)
  (let (selection ffmpeg-args
                  (file my-record-recording) result)
    (with-current-buffer my-record-segments-buffer
      (goto-char (point-min))
      (setq file (subed-guess-video-file))
      (setq selection (my-record-get-selection-for-region
                       (or beg (point-min))
                       (or end (point-max))))
      (setq ffmpeg-args (my-record-format-as-ffmpeg-selection selection)))
    (setq result
          (format "ffmpeg -y -i %s -af \"%s\" -vn -acodec libvorbis %s"
                  file
                  ffmpeg-args
                  "output.ogg"))
    (with-temp-file "output.vtt"
      (insert (my-record-format-as-vtt selection)))
    (shell-command-to-string result)))

(defun my-record-try-flow (&optional beg end)
  (interactive (list (if (region-active-p) (min (point) (mark)) (point-min))
                     (if (region-active-p) (max (point) (mark)) (point-max))
                     ))
  (save-excursion
    (shell-command-to-string (my-record-compose-audio beg end))
    (mpv-play "output.ogg")))

#+end_src

#+RESULTS:
:results:
my-record-try-flow
:end:

#+begin_export html
<style>
img { filter: drop-shadow(0 0.2rem 0.25rem rgba(0, 0, 0, 0.2)); display: block; width: 50%;  }
.figure p { text-align: left; font-style: italic }
</style>
#+end_export
** Web interface for controlling it

Set httpd-host to the IP address or hostname to have it listen beyond localhost.

#+begin_src emacs-lisp
(use-package simple-httpd)
(defservlet control text/html (path)
  (insert "
  <div id=\"feedback\"></div>
<div class=\"controller\">
  <button onclick=\"javascript:control('retry')\" style=\"background-color: red\">
    Retry
  </button>
  <button onclick=\"javascript:control('previous')\">
    Previous
  </button>
  <button onclick=\"javascript:control('accept')\" style=\"background-color: green\">
    Accept
  </button>
</div>
<style>
 .controller { display: flex; flex-direction: row }
 button { flex-grow: 1; font-size: 70px }
#feedback { font-size: 30px; }
</style>
<script>
function control(op) {
  fetch('/api/' + op + '/' + Date.now()).then(async function(res) {
    document.getElementById('feedback').innerText = await res.text();
  });
}
</script>
"))
(defvar my-record-script-buffer nil)

(defun my-record-web-op (path)
  (when (string-match "^/api/\\(previous\\|retry\\|accept\\)/\\([0-9]+\\)" path)
    (with-current-buffer my-record-script-buffer
      (funcall
       (pcase (match-string 1 path)
         ("previous" 'my-record-previous-segment)
         ("retry" 'my-record-retry-segment)
         ("accept" 'my-record-accept-segment))
       (seconds-to-time (/ (string-to-number (match-string 2 path)) 1000.0)))
      (buffer-substring (point) (save-excursion (forward-line 3) (point))))))

(defservlet api text/html (path)
  (insert (my-record-web-op path)))
#+end_src

#+RESULTS:
:results:
httpd/api
:end:
** Copy images
#+begin_src emacs-lisp
(defvar my-talk-script-heading "Talk plans")
(defvar my-talk-asset-dir "images")
(defun my-talk-copy-assets-to-subdir ()
  (interactive)
  (save-excursion
    (save-restriction
      (narrow-to-region (org-back-to-heading) (save-excursion (org-end-of-subtree)))
      (let (link link-start link-end filename)
        (while (re-search-forward org-link-bracket-re nil t)
          (setq link-start (match-beginning 0)
                link-end (match-end 0)
                link (org-link-unescape (match-string-no-properties 1)))
          (when (and (string-match "^file:\\(.*\\)" link)
                     (setq filename (match-string 1 link))
                     (not (file-in-directory-p filename my-talk-asset-dir)))
            (copy-file filename (expand-file-name (file-name-nondirectory filename) my-talk-asset-dir) t)
            (setq filename (expand-file-name (file-name-nondirectory filename) my-talk-asset-dir))
            (delete-region link-start link-end)
            (insert (org-link-make-string (concat "file:" (file-relative-name filename "."))))))))))
          
#+end_src

#+RESULTS:
:results:
my-talk-copy-assets-to-subdir
:end:

** Emoji support
(set-fontset-font "fontset-default" 'symbol "Noto Color Emoji" nil 'prepend)
** Waveforms

It looks like using the web interface on my phone to accept or retry segments adds too much of a delay, so I need to adjust some timestamps earlier. It might be easier to finetune timestamps if I can see the waveforms. [[https://github.com/larsmagne/wave][wave]] plots PCM data in Emacs. Maybe I can use [[https://trac.ffmpeg.org/wiki/Waveform][ffmpeg's showwavespic filter]] to show it. I think it would generally be useful to be able to see the waveform for a particular segment in a WebVTT subtitle file.

Oh hey, =my-subed-read-current-subtitle-ms-from-waveform= seems like it might work now. 
#+begin_src emacs-lisp
(defvar my-record-ffmpeg-executable "ffmpeg")
(defun my-record-get-waveform-for-whole-file (sound-file)
  (let* ((args
          (append
           (list "-i" sound-file)
           (list
            "-filter_complex"
            (format "showwavespic=s=%dx%d"
                    (* (my-record-segment-get-video-duration-ms sound-file) my-waveform-pixels-per-second 0.001)
                    my-waveform-height)
            "-frames:v"
            "1"
            "-y"
            (concat (file-name-sans-extension sound-file) ".png")))))
    (apply 'call-process
           my-record-ffmpeg-executable
           nil nil nil
           args)
    ;; (string-join (cons my-record-ffmpeg-executable args) " ")
    (concat (file-name-sans-extension sound-file) ".png")))

(defun my-record-get-waveform (sound-file output-file width height &optional start-ms end-ms)
  (setq start-ms (or start-ms 0))
  (let* ((args
          (append
;           (list "-ss" (format "%.3f" (/ start-ms 1000.0)))
           (list "-i" sound-file)
;           (if end-ms (list "-t" (format "%.3f" (/ (- end-ms start-ms) 1000.0))))
           ;(if end-ms (list "-to" (format "%.3f" (/ end-ms 1000.0)) "-copyts"))
           (list
            "-filter_complex"
            (shell-quote-argument
            (format "[0:a]aselect='between(t,%.3f,%.3f)',asetpts='N/SR/TB'[p];[p]showwavespic=s=%dx%d"
                    (/ start-ms 1000.0)
                    (/ end-ms 1000.0)
                    width height))
            "-frames:v"
            "1"
            "-y"
            output-file))))
    (apply 'call-process
           my-record-ffmpeg-executable
           nil nil nil
           args)
    (kill-new (string-join (cons my-record-ffmpeg-executable args) " "))
    output-file))

(defvar my-waveform-height 40)
(defvar my-waveform-clicked-ms nil "Milliseconds of the clicked time on the waveform.")
(defvar my-waveform-start-ms nil)
(defvar my-waveform-end-ms nil)

(defun my-waveform-mouse-event-to-ms (event)
  (let* ((x (car (elt (cadr event) 8)))
         (width (car (elt (cadr event) 9))))
    (+ (* (/ (* 1.0 x)
             width)
          (- (plist-get (cdr (elt (cadr event) 7)) :end-ms)
             (plist-get (cdr (elt (cadr event) 7)) :start-ms)))
       (plist-get (cdr (elt (cadr event) 7)) :start-ms))))

(defun my-waveform-subed-set-start (event)
  (interactive "e")
  (subed-set-subtitle-time-start (my-waveform-mouse-event-to-ms event))
  (my-waveform-subed-show-after-time))

(defun my-waveform-subed-set-stop (event)
  (interactive "e")
  (subed-set-subtitle-time-stop (my-waveform-mouse-event-to-ms event))
  (my-waveform-subed-show-after-time))

(defun my-waveform-subed-copy-timestamp (event)
  (interactive "e")
  (let* ((ms (my-waveform-mouse-event-to-ms event))
         (ts (subed-vtt--msecs-to-timestamp ms)))
    (message "%s" ts)
    (my-waveform-play-sample (plist-get (cdr (elt (cadr event) 7)) :filename)
                             ms (min
                                 (plist-get (cdr (elt (cadr event) 7)) :end-ms)
                                 (+ ms (* 1000.0 my-waveform-sample-seconds))))
    (kill-new ts)))

(defun my-waveform-subed-split (event)
  (interactive "e")
  (subed-split-subtitle (my-waveform-mouse-event-to-ms event))
  (my-waveform-subed-show-after-time))

(defvar my-waveform-timer nil)
(defvar my-waveform-sample-seconds 2)
(defun my-waveform-play-sample (file ms &optional end-ms)
  (mpv-kill)
  (mpv-start file (format "--start=%.3f" (/ ms 1000.0)) (format "--end=%.3f" (if end-ms (/ end-ms 1000.0)
                                                                               (+ (/ ms 1000.0) my-waveform-sample-seconds)))))

(defun my-waveform-minibuffer-select (event)
  (interactive "e")
  "Set `my-waveform-clicked-ms' to the timestamp of the clicked-on image."
  (let ((ms (my-waveform-mouse-event-to-ms event)))
    (setq my-waveform-clicked-ms ms)
    (message "%s" (subed-vtt--msecs-to-timestamp ms))
    (my-waveform-play-sample (plist-get (cdr (elt (cadr event) 7)) :filename) ms)))

(defvar my-waveform-subed-map
  (let ((map (make-sparse-keymap)))
    (define-key map [mouse-1] #'my-waveform-subed-set-start)
    (define-key map [mouse-2] #'my-waveform-subed-copy-timestamp)
    (define-key map [mouse-3] #'my-waveform-subed-set-stop)
    map))

(defvar my-waveform-minibuffer-map
  (let ((map (make-sparse-keymap)))
    (define-key map [mouse-1] #'my-waveform-minibuffer-select)
    (define-key map [ret] #'exit-recursive-edit)
    (define-key map [esc] #'abort-recursive-edit)
    (define-key map [q] #'abort-recursive-edit)
    map))
(defvar my-waveform-pixels-per-second 100)

(defun my-svg-embedded-image-at-offset (svg file type &rest args)
  "ARGS: :x :y :width :height :image-pos (x . y) :image-size (width . height)"
  (let* ((clip-path (svg-clip-path svg :id "clip")))
    (svg-rectangle clip-path 0 0
                   (plist-get args :width)
                   (plist-get args :height))
    (svg-embed svg file type nil
               :x (- (or (plist-get args :x) 0)
                     (car (plist-get args :image-pos)))
               :y (- (or (plist-get args :y) 0)
                     (cdr (plist-get args :image-pos)))
               :height (cdr (plist-get args :image-size))
               :width (car (plist-get args :image-size))
               :clip-path "url(#clip)")
    ;; (svg-print svg)
    svg))

(defun my-subed-make-waveform-string-from-image (sound-file image start-ms end-ms)
  (propertize "x"
              'display image
               'slice (list (* start-ms 0.001 my-waveform-pixels-per-second)
                           0
                           (* (- end-ms start-ms) 0.001 my-waveform-pixels-per-second)
                           my-waveform-height)
               'start-ms start-ms
               'end-ms end-ms
               'buffer (current-buffer)
               'filename sound-file))

(defun my-subed-make-waveform-string (sound-file start-ms end-ms &rest args)
  (let* ((image-filename (concat (file-name-sans-extension sound-file) ".png"))
         (image-size (or (plist-get args :image-size) (image-size (create-image image-filename) t)))
         (width (* (- end-ms start-ms) my-waveform-pixels-per-second 0.001)))
    (propertize "x"
                'display
                (let ((svg (svg-create
                            width
                            my-waveform-height
                            :start-ms start-ms
                            :end-ms end-ms
                            :buffer (current-buffer)
                            :filename sound-file)))
                  (svg-line svg 0 (/ my-waveform-height 2) width
                            (/ my-waveform-height 2) :stroke "yellow")
                  (my-svg-embedded-image-at-offset
                   svg image-filename "image/png"
                   :x 0 :y 0 :width width :height my-waveform-height
                   :image-pos (cons (* start-ms my-waveform-pixels-per-second 0.001) 0)
                   :image-size image-size)
                  (svg-image svg)))))

(defun my-waveform-subed-waveform-at-point (sound-file &optional image)
  (let* ((start-ms (subed-subtitle-msecs-start))
         (end-ms (subed-subtitle-msecs-stop))
         (image (or image (create-image (concat (file-name-sans-extension (subed-guess-video-file)) ".png")))))
    (my-subed-make-waveform-string-from-image sound-file image start-ms end-ms)))

(defun my-waveform-subed-remove-all ()
  (interactive)
  (remove-overlays (point-min) (point-max) 'waveform t))

(defun my-waveform-subed-show-after-time (&optional filename image)
  (interactive)
  (let* ((image-filename (or filename (my-record-get-waveform-for-whole-file (subed-guess-video-file))))
         (image (or image (create-image image-filename))))
    (save-excursion
      (remove-overlays
       (subed-jump-to-subtitle-time-start)
       (or (subed-jump-to-subtitle-end) (point-max))
       'waveform t)
      (subed-jump-to-subtitle-time-stop)      
      (end-of-line)
      (let ((overlay (make-overlay (point) (point))))
        (overlay-put overlay 'waveform t)  
        (overlay-put overlay 'before-string (propertize
                                             (my-waveform-subed-waveform-at-point image-filename image)
                                             'keymap
                                             my-waveform-subed-map))))))

(defun my-subed-show-waveforms ()
  (interactive)
  (let* ((sound-file (subed-guess-video-file))
         (image-filename
          (my-record-get-waveform-for-whole-file
           (subed-guess-video-file)
           (concat (file-name-sans-extension (subed-guess-video-file)) ".png")))
         (image (create-image image-filename) t))
    (subed-for-each-subtitle (point-min) (point-max) nil
      (save-excursion (my-waveform-subed-show-after-time sound-file image)))))

(defun my-subed-read-current-subtitle-ms-from-waveform ()
  (interactive)
  (let* ((start-ms (subed-subtitle-msecs-start))
         (end-ms (subed-subtitle-msecs-start))
         (image-string (my-waveform-subed-waveform-at-point ))
         (subed-file (current-buffer)))
    (pop-to-buffer (get-buffer-create "*Waveform*"))    
    (erase-buffer)
    (insert (propertize image-string 'keymap my-waveform-minibuffer-map))
    (save-excursion
      (save-window-excursion
        (unwind-protect
            (recursive-edit)
          (when (get-buffer "*Waveform*")
            (delete-window)
            (kill-buffer "*Waveform*")))))
    my-waveform-clicked-ms))
;; (my-record-get-waveform
;;  "~/code/emacsconf-2021-emacs-news-highlights/tmp/2021-10-21-234703.ogg"
;;  "tmp/waveform.png"
;;  2000
;;  60
;;  )
#+end_src

#+RESULTS:
:results:
my-subed-read-current-subtitle-ms-from-waveform
:end:

** SVG screenshots
#+begin_src emacs-lisp
(defun screenshot-svg ()
  "Save a screenshot of the current frame as an SVG image.
Saves to a temp file and puts the filename in the kill ring."
  (interactive)
  (let* ((data (x-export-frames nil 'svg))
         (filename (expand-file-name (format-time-string "%Y-%m-%d-%H%M%S.svg") my-screenshot-directory)))
    (with-temp-file filename 
      (insert data))
    (kill-new filename)
    (message filename)))
    #+end_src

    #+RESULTS:
    :results:
    screenshot-svg
    :end:
* Backstory
- previous
  - Record everything, edit in Audacity, and then align afterwards in Emacs or via YouTube
  - Easiest audio editing, but time info gets lost, have to do it again afterwards. Also editing is a little mouse-heavy, but I guess that's okay
- rough outline
- filled in with top posts, review of Emacs News Highlights
- draft
- links
- wrapped at ~49 characters with help from display-fill-column-indicator-mode
- recorded audio using a hydra to capture timestamps
- keyboard sound was too loud
- web interface
- tried using Georgi keyboard, still a bit loud

- visuals
  - collecting
  - compiling
    - images
    - animated GIFs
    - speeding up videos
- burning in descriptions
- display waveforms
- buttons? but I can't seem to move the point from a button lambda.
- ugh. Next attempt: record longer segments, and then split things
  afterwards

* Links from figuring things out
** GitHub - larsmagne/wave: Editing and (auto-)splitting PCM files from Emacs
:PROPERTIES:
:CREATED:  [2021-10-20 Wed 09:26]
:END:

https://github.com/larsmagne/wave
https://lars.ingebrigtsen.no/2011/04/17/editing-sound-files-in-emacs/amp/


* Image credits and sources

- async-python-demo: https://blog.tecosaur.com/tmio/2021-05-31-async.html
- org-roam-ui image: [[https://github.com/org-roam/org-roam-ui][org-roam-ui homepage]]
- bufler taxy magit-section: [[https://www.reddit.com/r/emacs/comments/pkuwcq/and_bufler_taxy_magitsection_a_concise_language/][github-alphapapa]]
- consult-grep animated gif: https://github.com/minad/consult
- orderless screenshot: https://github.com/oantolin/orderless  
- evil-textobj animated gif: https://github.com/meain/evil-textobj-tree-sitter
- parinfer-rust animated gif: https://github.com/justinbarclay/parinfer-rust-mode
- opengl: [[https://www.reddit.com/r/emacs/comments/kn3fzq/draw_anything_to_emacs_buffers_with_opengl/][SnowyHarbor]]
- SVG modelines: https://github.com/ocodo/ocodo-svg-modelines
- Gantt chart: https://github.com/Aightech/org-gantt-svg
- scribble: https://lifeofpenguin.blogspot.com/2021/08/scribble-notes-in-gnu-emacs.html
- el-easydraw diagrams, color picker: https://github.com/misohena/el-easydraw
- svg-icons: https://github.com/rougier/emacs-svg-icon
- svg-lib: https://github.com/rougier/svg-lib
- boxy-headings animated gif: https://gitlab.com/tygrdev/boxy-headings
- boxy-imenu animated gif: https://gitlab.com/tygrdev/boxy-imenu
- org-real animated gif: https://gitlab.com/tygrdev/org-real
- minibuffer interaction paradigm: https://karthinks.com/software/avy-can-do-anything/
