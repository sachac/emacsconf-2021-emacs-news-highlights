#+TITLE: Emacs News Highlights
#+OPTIONS: toc:1

| Talk page            | https://emacsconf.org/2021/talks/news            |rt
| Contact              | Sacha Chua [[mailto:sacha@sachachua.com][sacha@sachachua.com]]                             |
# | Video with subtitles | [[file:emacs-conf-2020-emacs-news-highlights-sacha-chua.webm]] |
# | Audio only           | [[file:audio.ogg]]                                             |

(* 5 150) 750

Draft of my talk for EmacsConf 2021 based on highlights from https://sachachua.com/emacs-news

* Talk plans
:PROPERTIES:
:CUSTOM_ID: script
:END:

#+CAPTION: Emacs News Highlights - emacsconf.org/2021/talks/news
[[file:images/Screenshot_20211021_002952.png]] 

I'm Sacha Chua, and here are 
ten Emacs News highlights for 2021.
If you want to follow the links,
check out the wiki page at
https://emacsconf.org/2021/talks/news/ .

#+CAPTION: 1. Emacs NEWS.28 - git.savannah.gnu.org/cgit/emacs.git/tree/etc/NEWS.28
[[file:images/Screenshot_20211020_095333.png]]

1. The Emacs developers are currently
   working on [[https://git.savannah.gnu.org/cgit/emacs.git/tree/etc/NEWS.28][Emacs 28.1]],
   which will be the next major release.

   #+CAPTION: Native compilation featured on System Crafters, www.youtube.com/watch?v=i8OLg-f9EHk
   [[file:images/Screenshot_20211020_095812.png]]
   
   [[https://www.youtube.com/watch?v=i8OLg-f9EHk][Native compilation]] should
   make everything way faster,

   #+CAPTION: Emoji support
   [[file:images/EmacslZhRzr.svg]]

   and emoji support will probably
   make things more fun. üòéüëç
   
   John Wiegley will share more Emacs 28 details
   in his update, so check out his talk.

2.
   #+CAPTION: 2. Org Mode 9.5 - orgmode.org/Changes.html
   [[file:images/Screenshot_20211020_100623.png]]

   [[https://orgmode.org/Changes.html][Org Mode is now at version 9.5]].
   New features include
   a library for [[https://blog.tecosaur.com/tmio/2021-07-31-citations.html#fn.3][managing citations]],

   #+CAPTION: asynchronous session support in Python - blog.tecosaur.com/tmio/2021-05-31-async.html
   [[file:images/org-async-python-demo.mp4]]
   
   [[https://blog.tecosaur.com/tmio/2021-05-31-async.html][asynchronous session support]]
   for code blocks,

   #+CAPTION: New faces for agenda - orgmode.org/Changes.html
   [[file:images/Screenshot_20211020_101636.png]]

   and better control
   of your [[https://orgmode.org/Changes.html][agenda's appearance]].
   
   #+CAPTION: Org Mode 9.5 - orgmode.org/Changes.html
   [[file:images/Screenshot_20211020_100623.png]]
   If you've been getting your Org packages
   from Org ELPA,
   you can update your configuration
   to get Org from GNU ELPA
   and org-contrib from NonGNU ELPA.

   #+CAPTION: Org Roam v2 - blog.jethro.dev/posts/org_roam_v2/
   [[file:images/Screenshot_20211020_101756.png]]

   The [[https://blog.jethro.dev/posts/org_roam_v2/][new release of the Org Roam package]] ([[https://blog.tecosaur.com/tmio/2021-08-38-roaming.html][TMIO]])
   should be a faster and more consistent way
   to use Org to manage a knowledgebase,

   #+CAPTION: Org Roam UI - github.com/org-roam/org-roam-ui/
   [[file:images/org-roam-ui.png]]
   
   and [[https://github.com/org-roam/org-roam-ui/][org-roam-ui]] looks pretty snazzy.

   #+CAPTION: blog.tecosaur.com/tmio
   [[file:images/Screenshot_20211020_101922.png]]

   The best way to keep up with Org changes
   is to check out the blog [[https://blog.tecosaur.com/tmio/][This Month in Org]].

3.
   #+CAPTION: 3. Magit 3 - emacsair.me/2021/05/25/magit-3.0/
   [[file:images/Screenshot_20211020_102028.png]]

   New [[https://emacsair.me/2021/05/25/magit-3.0/][Magit major release]]!
   Jonas Bernoulli has split some functionality
   into other packages so that
   Emacs Lisp developers can use them, such as
   magit-section, transient, and forge.

   #+CAPTION: (and Bufler Taxy Magit-Section) - www.reddit.com/r/emacs/comments/pkuwcq
   [[file:images/Screenshot_20211020_102147.png]]

   Here's an example of using magit-section to
   [[https://www.reddit.com/r/emacs/comments/pkuwcq/and_bufler_taxy_magitsection_a_concise_language/][manage groups of buffers]].

   #+CAPTION: Self-describing Smart DSLs - emacsconf.org/2021/talks/dsl/
   [[file:images/Screenshot_20211020_102242.png]]

   You can learn more about Transient
   in the talk on [[https://emacsconf.org/2021/talks/dsl/][self-describing 
   smart domain-specific languages]] or DSLs.
   
4. 
   #+CAPTION: 4. Completion - karthinks.com/software/avy-can-do-anything/
   [[file:images/minibuffer-interaction-paradigm.png]]
   In terms of smaller packages, there's been
   a lot of activity around completion.
   [[https://karthinks.com/software/avy-can-do-anything/][Karthik has this great diagram.]]
   I think the idea is that instead of having
   one large completion system
   like Helm or Icicles, you can choose
   a few different, smaller packages
   and configure them to work together.
   If you're curious about this, 
   you might start with either
     
     #+CAPTION: selectrum - github.com/raxod502/selectrum
     [[file:images/Screenshot_20211020_204634.png]]
     [[https://github.com/raxod502/selectrum][selectrum]] 
     #+CAPTION: Vertico - github.com/minad/vertico
     [[file:images/vertico.svg]]
     or [[https://github.com/minad/vertico][vertico]],
     which are both completion interfaces,

     #+CAPTION: marginalia - github.com/minad/marginalia
     [[file:images/Screenshot_20211020_212130.png]]
     add [[https://github.com/minad/marginalia][marginalia]] for more information,
        
     #+CAPTION: consult - github.com/minad/consult
     [[file:images/consult-grep.gif]]
     and try [[https://github.com/minad/consult][consult]] for many useful
     completing commands.
     
   #+CAPTION: On completion frameworks - www.reddit.com/r/emacs/comments/ppg98f
   [[file:images/Screenshot_20211020_212308.png]]

   There are so many options, 
   so it might be useful to check out
   [[https://www.reddit.com/r/emacs/comments/ppg98f/which_completion_framework_do_you_use_and_why/][some discussions]].
5. 
   #+CAPTION: 5. Embark - github.com/oantolin/embark
   [[file:images/Screenshot_20211020_212456.png]]
   [[https://github.com/oantolin/embark][Embark]] is usually mentioned as part of  
   that group of packages, 
   but it's well worth looking into
   even if you use a different system. 
   It lets you choose an action 
   based on an object, which is handy for 
   when you start with one command 
   and then realize that 
   you actually want to do something else. 
   #+CAPTION: Fifteen ways to use Embark - karthinks.com/software/fifteen-ways-to-use-embark/
   [[file:images/Screenshot_20211020_212529.png]]
   For more ideas, check out 
   [[https://karthinks.com/software/fifteen-ways-to-use-embark/][Fifteen Ways to Use Embark]].
   
6. 
   #+CAPTION: Tree-sitter-powered editing - https://emacsconf.org/2021/talks/structural/
   [[file:images/Screenshot_20211022_171008.png]]
   Now that there are Emacs Lisp bindings 
   for tree-sitter, we can work more easily
   with the structure of code instead of 
   just using regular expressions.
   Check out the talk
   on [[https://emacsconf.org/2021/talks/structural/][Tree-edit and structural editing]]
   to learn more.
   #+CAPTION: 6. tree-sitter-powered Emacs Lisp - blog.meain.io/2021/intelligent-snippets-treesitter/
   [[file:images/Screenshot_20211020_212756.png]]
   You can use tree-sitter for
   [[https://blog.meain.io/2021/intelligent-snippets-treesitter/][intelligent snippets]] that get information 
   from the code around them,
   #+CAPTION: github.com/polaris64/symex-ts
   [[file:images/Screenshot_20211020_213017.png]]
   [[https://github.com/polaris64/symex-ts][editing Lisp expressions]], 
   #+CAPTION: github.com/meain/evil-textobj-tree-sitter
   [[file:images/evil-textobj.gif]]
   and [[https://github.com/meain/evil-textobj-tree-sitter][navigating text objects in Evil mode.]] 
   (That's when Emacs is pretending to be Vi.) 
   Dynamic modules help us add more to Emacs 
   than Emacs Lisp easily offers,
   #+CAPTION: GopCaml - www.youtube.com/watch?v=KipRuiLXYEo
   [[file:images/Screenshot_20211020_213235.png]]
   such as [[https://www.youtube.com/watch?v=KipRuiLXYEo][structural editing in OCaml]]
   #+CAPTION: parinfer-rust - github.com/justinbarclay/parinfer-rust-mode
   [[file:images/parinfer-rust.gif]]
   and [[https://github.com/justinbarclay/parinfer-rust-mode#installing][using Rust to figure out parentheses]]
   and indentation for Lisp.
   #+CAPTION: Extending Emacs in Rust with Dynamic Modules - emacsconf.org/2021/talks/rust/
   [[file:images/Screenshot_20211020_213423.png]]
   If you're curious about dynamic modules,
   check out the talk on
   [[https://emacsconf.org/2021/talks/rust/][Extending Emacs in Rust with Dynamic Modules]].
7. 
   #+CAPTION: 7. CRDT - collaborative editing - elpa.gnu.org/packages/crdt.html
   [[file:images/Screenshot_20211020_213543.png]]
   Collaborative editing is now much easier 
   since the [[https://elpa.gnu.org/packages/crdt.html][CRDT]] package is in GNU ELPA. ([[https://www.reddit.com/r/emacs/comments/pdi08v/crdtel_the_collaborative_editing_package_now_on/][Reddit]]) 
   It allows multiple people to edit 
   the same file over the network, 
   using their own Emacs. 
   This means you can keep your own config
   and keybindings, yay! 
   #+CAPTION: Emacs Research Group - emacsconf.org/2021/talks/erg/
   [[file:images/Screenshot_20211020_213619.png]]
   Watch the [[https://emacsconf.org/2021/talks/erg/][Emacs Research Group talk]] 
   for an example of how several people 
   used it to work together.
8.
   #+CAPTION: 8. More graphical experiments: OpenGL - www.reddit.com/r/emacs/comments/kn3fzq
   [[file:images/opengl.png]]
   In case you're still under the impression 
   that Emacs is just a text editor, 
   some folks have been working on 
   pretty neat graphical experiments.
   These [[https://www.reddit.com/r/emacs/comments/kn3fzq/draw_anything_to_emacs_buffers_with_opengl/][OpenGL bindings for Emacs Lisp]] 
   use an embedded xwidget,
   while other prototypes use the SVG support
   that's built into Emacs
   #+CAPTION: Gantt charts - github.com/Aightech/org-gantt-svg
   [[file:images/Screenshot_20211020_214059.png]]
   for [[https://github.com/Aightech/org-gantt-svg][Gantt charts]] ([[https://www.reddit.com/r/emacs/comments/prezj6/simple_gantt_chart_from_an_org_todo_list_with_svg/][Reddit]]),

   #+CAPTION: Scribble - lifeofpenguin.blogspot.com/2021/08/scribble-notes-in-gnu-emacs.html
   [[file:images/scribble.png]]
   [[https://lifeofpenguin.blogspot.com/2021/08/scribble-notes-in-gnu-emacs.html][scribbles]],
   #+CAPTION: el-easydraw - www.reddit.com/r/emacs/comments/pvtbq5
   [[file:images/Screenshot_20211020_214428.png]]
   and even [[https://www.reddit.com/r/emacs/comments/pvtbq5/emacs_drawing_tool/][diagrams]]. ([[https://www.reddit.com/r/emacs/comments/pvtbq5][Reddit]])
   #+CAPTION: el-easydraw color picker - github.com/misohena/el-easydraw
   [[file:images/color-picker-minibuffer.png]]
   The color-picker from that one 
   looks particularly useful for CSS.
   If you want to play around with adding SVGs 
   to your files and interfaces,
   #+CAPTION: svg-icon - github.com/rougier/emacs-svg-icon
   [[file:images/svg-icons.png]]
   [[https://github.com/rougier/emacs-svg-icon][svg icon]]
   #+CAPTION: svg-lib - elpa.gnu.org/packages/svg-lib.html
   [[file:images/svg-lib.png]]
   and [[https://elpa.gnu.org/packages/svg-lib.html][svg-lib]] 
   might be good places to start. ([[https://www.reddit.com/r/emacs/comments/pyee44/svglib_is_on_elpa/][Reddit]])
   Of course, there's always a place 
   for ASCII art,
   #+CAPTION: boxy-headings - www.reddit.com/r/emacs/comments/q2z29f
   [[file:images/boxy-headings.gif]]
   especially with the new [[https://gitlab.com/tygrdev/boxy][boxy]] package
   that you can use for [[https://www.reddit.com/r/emacs/comments/q2z29f/boxyheadlines_and_orgreal_are_now_on_elpa/][org files]],
   #+CAPTION: boxy-imenu - gitlab.com/tygrdev/boxy-imenu
   [[file:images/boxy-imenu.gif]]
   [[https://gitlab.com/tygrdev/boxy-imenu][imenu navigation]],
   #+CAPTION: org-real - gitlab.com/tygrdev/org-real
   [[file:images/org-real.gif]]
   and even [[https://gitlab.com/tygrdev/org-real][things in real life]].
9. 
   #+CAPTION: 9. Lots of posts and videos: System Crafters... - systemcrafters.cc/
   [[file:images/Screenshot_20211021_002413.png]]
   There have been a lot of great posts, videos 
   and livestreams about Emacs this year.
   In addition to the ones from [[https://systemcrafters.cc/][System Crafters]],
   #+CAPTION: Emacs Elements... - www.youtube.com/channel/UCe5excZqMeG1CIW-YhMTCEQ
   [[file:images/Screenshot_20211021_002120.png]]
   [[https://www.youtube.com/channel/UCe5excZqMeG1CIW-YhMTCEQ][Emacs Elements]],
   #+CAPTION: Protesilaos Stavrou... - protesilaos.com/
   [[file:images/Screenshot_20211021_002254.png]]
   and [[https://protesilaos.com/][Protesilaos]] 
   (who has started livestreaming),
   #+CAPTION: John Kitchin... - www.youtube.com/user/jrkitchin
   [[file:images/Screenshot_20211021_002218.png]]
   [[https://www.youtube.com/user/jrkitchin][John Kitchin]]
   #+CAPTION: Mike Zamansky - cestlaz.github.io/categories/emacs/
   [[file:images/Screenshot_20211021_002452.png]]
   and [[https://cestlaz.github.io/categories/emacs/][Mike Zamansky]] 
   are both back, hooray!
10. 
    #+CAPTION: 10. #emacs on libera.chat - www.emacswiki.org/emacs/EmacsChannel
    [[file:images/Screenshot_20211021_002604.png]]
    Lastly, if you want to chat 
    with other Emacs folks
    and get help on Emacs, Org Mode, 
    or other topics, the #emacs and #org-mode
    Internet Relay Chat or IRC channels
    are now on the [[https://libera.chat]] network
    instead of Freenode. ([[https://www.emacswiki.org/emacs/EmacsChannel][EmacsWiki]])

#+CAPTION: Emacs News Highlights - emacsconf.org/2021/talks/news
[[file:images/Screenshot_20211021_002952.png]]

If you'd like to add something I've missed,
please add them to the collaborative pad
if you're watching this live, 
add them to the wiki page, 
or e-mail me at [[mailto:sacha@sachachua.com][sacha@sachachua.com]] . 
That's all for this quick review. 
Enjoy the rest of EmacsConf 2021!

* Just the text
#+begin_src emacs-lisp
(save-excursion
  (goto-char (org-find-exact-headline-in-buffer "Talk plans"))
  (org-end-of-meta-data)
  (replace-regexp-in-string
   "\\[\\[.*?\\]\\[\\(\\([^]]+\\|\n\\)*?\\)\\]\\]"
   "\\2"
   (replace-regexp-in-string "\n[ \t\n]*\n" "\n" (replace-regexp-in-string
                                                  "#\\+CAPTION:.*\n\\|\\[\\[file:.*?\\]\\]" ""
                                                  (buffer-substring-no-properties (point) 
                                                                                  (org-end-of-subtree))))))

#+end_src

#+RESULTS:
:results:

I'm Sacha Chua, and here are 
ten Emacs News highlights for 2021.
If you want to follow the links,
check out the wiki page at
https://emacsconf.org/2021/talks/news/ .
1. The Emacs developers are currently
   working on Emacs 28.1,
   which will be the next major release.
   Native compilation should
   make everything way faster,
   and emoji support will probably
   make things more fun. üòéüëç
   John Wiegley will share more Emacs 28 details
   in his update, so check out his talk.
2.
   Org Mode is now at version 9.5.
   New features include
   a library for managing citations,
   asynchronous session support
   for code blocks,
   and better control
   of your agenda's appearance.
   If you've been getting your Org packages
   from Org ELPA,
   you can update your configuration
   to get Org from GNU ELPA
   and org-contrib from NonGNU ELPA.
   The new release of the Org Roam package (TMIO)
   should be a faster and more consistent way
   to use Org to manage a knowledgebase,
   and org-roam-ui looks pretty snazzy.
   The best way to keep up with Org changes
   is to check out the blog This Month in Org.
3.
   New Magit major release!
   Jonas Bernoulli has split some functionality
   into other packages so that
   Emacs Lisp developers can use them, such as
   magit-section, transient, and forge.
   Here's an example of using magit-section to
   manage groups of buffers.
   You can learn more about Transient
   in the talk on self-describing 
   smart domain-specific languages or DSLs.
4. 
   In terms of smaller packages, there's been
   a lot of activity around completion.
   Karthik has this great diagram.
   I think the idea is that instead of having
   one large completion system
   like Helm or Icicles, you can choose
   a few different, smaller packages
   and configure them to work together.
   If you're curious about this, 
   you might start with either
     selectrum 
     or vertico,
     which are both completion interfaces,
     add marginalia for more information,
     and try consult for many useful
     completing commands.
   There are so many options, 
   so it might be useful to check out
   some discussions.
5. 
   Embark is usually mentioned as part of  
   that group of packages, 
   but it's well worth looking into
   even if you use a different system. 
   It lets you choose an action 
   based on an object, which is handy for 
   when you start with one command 
   and then realize that 
   you actually want to do something else. 
   For more ideas, check out 
   Fifteen Ways to Use Embark.
6. 
   Now that there are Emacs Lisp bindings 
   for tree-sitter, we can work more easily
   with the structure of code instead of 
   just using regular expressions.
   Check out the talk
   on Tree-edit and structural editing
   to learn more.
   You can use tree-sitter for
   intelligent snippets that get information 
   from the code around them,
   editing Lisp expressions, 
   and navigating text objects in Evil mode. 
   (That's when Emacs is pretending to be Vi.) 
   Dynamic modules help us add more to Emacs 
   than Emacs Lisp easily offers,
   such as structural editing in OCaml
   and using Rust to figure out parentheses
   and indentation for Lisp.
   If you're curious about dynamic modules,
   check out the talk on
   Extending Emacs in Rust with Dynamic Modules.
7. 
   Collaborative editing is now much easier 
   since the CRDT package is in GNU ELPA. (Reddit) 
   It allows multiple people to edit 
   the same file over the network, 
   using their own Emacs. 
   This means you can keep your own config
   and keybindings, yay! 
   Watch the Emacs Research Group talk 
   for an example of how several people 
   used it to work together.
8.
   In case you're still under the impression 
   that Emacs is just a text editor, 
   some folks have been working on 
   pretty neat graphical experiments.
   These OpenGL bindings for Emacs Lisp 
   use an embedded xwidget,
   while other prototypes use the SVG support
   that's built into Emacs
   for Gantt charts (Reddit),
   scribbles,
   and even diagrams. (Reddit)
   The color-picker from that one 
   looks particularly useful for CSS.
   If you want to play around with adding SVGs 
   to your files and interfaces,
   svg icon
   and svg-lib 
   might be good places to start. (Reddit)
   Of course, there's always a place 
   for ASCII art,
   especially with the new boxy package
   that you can use for org files,
   imenu navigation,
   and even things in real life.
9. 
   There have been a lot of great posts, videos 
   and livestreams about Emacs this year.
   In addition to the ones from System Crafters,
   Emacs Elements,
   and Protesilaos 
   (who has started livestreaming),
   John Kitchin
   and Mike Zamansky 
   are both back, hooray!
10. 
    Lastly, if you want to chat 
    with other Emacs folks
    and get help on Emacs, Org Mode, 
    or other topics, the #emacs and #org-mode
    Internet Relay Chat or IRC channels
    are now on the [[https://libera.chat]] network
    instead of Freenode. (EmacsWiki)
If you'd like to add something I've missed,
please add them to the collaborative pad
if you're watching this live, 
add them to the wiki page, 
or e-mail me at sacha@sachachua.com . 
That's all for this quick review. 
Enjoy the rest of EmacsConf 2021!
:end:


* Tasks
** WAITING Coordinate with johnw
:LOGBOOK:
- State "WAITING"    from "TODO"       [2021-10-20 Wed 09:48] \\
  Waiting for update
:END:
** DONE Record audio
CLOSED: [2021-10-20 Wed 09:48]
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-10-20 Wed 09:48]
:END:
** DONE Collect visuals
CLOSED: [2021-10-21 Thu 00:38]
:PROPERTIES:
:Effort:   1:00
:QUANTIFIED: Emacs
:END:
:LOGBOOK:
- State "DONE"       from "STARTED"    [2021-10-21 Thu 00:38]
CLOCK: [2021-10-20 Wed 09:48]
:END:
** TODO Rerecord audio
** TODO Merge audio from different files
** DONE Figure out how to stitch visuals together
CLOSED: [2021-10-22 Fri 17:14]
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-10-22 Fri 17:14]
:END:

ffmpeg?

#+begin_src emacs-lisp

#+end_src

#+RESULTS:
:results:
nil
:end:

Actually, I'd like to get these out of the vtt as well, so I can determine timing.

#+begin_src emacs-lisp
(defmacro my-talk-with-script (&rest body)
  (declare (debug t))
  `(with-current-buffer my-record-script-buffer
     (save-restriction
       (save-excursion
         (goto-char (org-find-exact-headline-in-buffer my-talk-script-heading))
         (narrow-to-region (save-excursion (org-end-of-meta-data) (point)) (save-excursion (org-end-of-subtree)))
         ,@body))))

(defun my-record-segment-get-video-duration-ms (filename)
  (* 1000
     (string-to-number
      (shell-command-to-string
       (concat "ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "
               (shell-quote-argument (expand-file-name filename)))))))

(defun my-record-segment-get-frames (filename)
  (string-to-number
   (shell-command-to-string
    (concat "ffprobe -v error -select_streams v:0 -count_packets -show_entries stream=nb_read_packets -of csv=p=0 "
            (shell-quote-argument (expand-file-name filename))))))

(defvar my-record-description-height 50 "Number of pixels for top description in video.")
(defvar my-record-caption-height 150 "Number of pixels to leave at the bottom for captions in video.")
(defvar my-record-output-video-width 1280)
(defvar my-record-output-video-height 720)
(defun my-record-segment-scale-filter (o)
  "Return the complex filter for scaling."
  (seq-let (start-ms end-ms caption description) o
    (format "scale=%d:%d:force_original_aspect_ratio=decrease,setsar=sar=1,pad=%d:%d:(ow-iw)/2:%d+(oh-%d-%d-ih)/2"
            my-record-output-video-width
            (- my-record-output-video-height (or my-record-caption-height 0) (or my-record-description-height 0))
            my-record-output-video-width
            my-record-output-video-height
            my-record-description-height
            my-record-description-height
            my-record-caption-height
            )))

(defvar my-record-description-drawtext-filter-params "fontcolor=white:x=5:y=5:fontsize=40:font=sachacHand")
(defun my-record-format-selection-as-visuals (selection)
  (let* (info)
    (setq info
          (seq-map-indexed
           (lambda (o i)
             (seq-let (start-ms end-ms caption description description-filter) o
               (setq description-filter
                     (if description
                         (concat ",drawtext=\"" my-record-description-drawtext-filter-params ":text='"
                                 description ; TODO quote this properly
                                 "'\"")
                       ""))
               (when (string-match "file:\\([^]]+\\)" caption)
                 (let* ((filename (match-string 1 caption))
                        (duration (- end-ms start-ms))
                        (scale (my-record-segment-scale-filter o)))
                   (cond
                    ((string-match "mp4" caption)
                     (list
                      (format "-i %s" filename)
                      (let ((video-duration (my-record-segment-get-video-duration-ms filename)))
                        (format
                         "[%d:v]setpts=PTS*%.3f,%s%s[r%d];"
                         i
                         (/ duration video-duration)
                         scale
                         description-filter
                         i))))
                    ((string-match "gif$" filename)
                     (let ((gif-frames (my-record-segment-get-frames filename)))
                       (list
                        (format "-r %0.3f -i %s" (/ gif-frames (/ duration 1000.0)) filename)
                        ;; (format "-i %s" filename)
                        (format "[%d:v]%s%s[r%d];" i scale description-filter i))))
                    (t
                     (list
                      (format "-loop 1 -t %0.3f -i %s"
                              (/ duration 1000.0)
                              (shell-quote-argument filename))
                      (format "[%d:v]%s%s[r%d];" i scale description-filter i))))))))
           selection))
    (concat
     (mapconcat 'car info " ")
     " -filter_complex \""
     (mapconcat 'cadr info "")
     (mapconcat
      (lambda (o) (format "[r%d]" o))
      (number-sequence 0 (1- (length selection)))
      "")
     (format "concat=n=%d:v=1:a=0\"" (length selection)))))
(defvar my-record-segments-buffer "*Segments*" "Buffer with the segments.")
(defun my-record-compile-visuals ()
  (interactive)
  (let ((result
         (concat "ffmpeg -y "
                 (with-current-buffer my-record-segments-buffer
                   (my-record-format-selection-as-visuals (my-record-get-selection-for-region (point-min) (point-max))))
                 " -shortest -c:v vp8 -vsync 1 -b:v 800k visuals.webm")))
    (kill-new result)
    result))
(defun my-record-test-visuals (&optional limit)
  (interactive "p")
  (let* ((visuals (my-talk-with-script
                   (cl-loop
                    while (re-search-forward "#\\+CAPTION: \\(.+\\)\n[ \t]*\\(\\[\\[file:[^]]+\\]\\)" nil t)
                    collect (list 1000 2000
                                  (match-string-no-properties 2)
                                  (match-string-no-properties 1)
                                  ))))
         (result
          (concat "ffmpeg -y "
                  (with-current-buffer my-record-segments-buffer
                    (my-record-format-selection-as-visuals
                     (if (> limit 1)
                         (seq-take visuals limit)
                       visuals)
                     ))
                  " -i visuals.vtt -c:v vp8 -vsync 2 -b:v 800k visuals.webm")))
    (kill-new result)
    result))
#+end_src

#+RESULTS:
:results:
my-record-test-visuals
:end:
*** DONE handle animated gifs
CLOSED: [2021-10-22 Fri 17:14]
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-10-22 Fri 17:14]
:END:
https://unix.stackexchange.com/questions/40638/how-to-do-i-convert-an-animated-gif-to-an-mp4-or-mv4-on-the-command-line
*** DONE squeeze videos to fit
CLOSED: [2021-10-22 Fri 17:14]
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-10-22 Fri 17:14]
:END:
** DONE Figure out what to do about resolution
CLOSED: [2021-10-22 Fri 17:15]
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-10-22 Fri 17:15]
:END:
1366x768,
wanted 1280x720,
my images are small

Oh, just needed bitrate

** TODO Tweak audio editing so that I can bisect the start or end given an offset
#+begin_src emacs-lisp

#+end_src
** TODO Tweak caption timing and include it
** TODO Put everything together and send the video
* Code
** STARTED Recording tool
:PROPERTIES:
:CREATED:  [2021-10-19 Tue 21:07]
:Effort:   1:00
:QUANTIFIED: Emacs
:END:
:LOGBOOK:
CLOCK: [2021-10-19 Tue 23:03]
:END:

Goal:

Srt or vtt file with subtitle copies so that I can easily replay segments, delete the ones I don't want to keep, and then use ffmpeg to collapse it into a smooth audio track.

Interface:

#+begin_src emacs-lisp
(obs-websocket-connect)
#+end_src

#+RESULTS:
:results:
t
:end:

#+begin_src emacs-lisp
(defvar my-record-backend nil "Either 'sox, 'obs, or nil.")
(defvar my-record-frontend 'hydra "Either 'hydra or 'web.")
(defvar my-record-directory "tmp")
(defvar my-record-audio-extension ".ogg")
(defvar my-record-start nil "Start of the current recording segment in milliseconds.")
(defvar my-record-end nil "End of current recording sgement in milliseconds.")
(defvar my-record-caption nil "Current caption.")
(defvar my-record-paused nil "If non-nil, recording is currently paused.")

(defvar my-record-sox-process nil "Process for recording via sox.")
(defvar my-record-sox-buffer "*Sox*")
(defvar my-record-sox-executable "rec")
(defvar my-record-sox-channels 1)
(defvar my-record-sox-rate 48000)
(defvar my-record-start-time nil "Emacs timestamp from when the sox process was started.")
(defvar my-record-sox-filename nil)

(defun my-record-current-filename ()
  (cond
   ((eq my-record-backend 'obs) obs-websocket-recording-filename)
   ((eq my-record-backend 'sox) my-record-sox-filename)
   (t "")))
(defun my-record-offset-ms (&optional time)
  (cond
   ((eq my-record-backend 'obs) (my-obs-websocket-recording-time-msecs))
   (t (* (float-time (time-subtract (or time (current-time)) my-record-start-time)) 1000.0)))) ; sox or nil

(defun my-record-sox-start (&optional filename)
  (interactive)
  (setq my-record-sox-filename
        (or filename
            (expand-file-name
             (concat (format-time-string "%Y-%m-%d-%H%M%S") my-record-audio-extension)
             my-record-directory)))
  (setq my-record-sox-buffer
        (get-buffer-create my-record-sox-buffer))
  (if (process-live-p my-record-sox-process)
      (quit-process my-record-sox-process))
  (kill-new my-record-sox-filename)
  (setq my-record-sox-process
        (start-process
         "sox"
         my-record-sox-buffer
         my-record-sox-executable
         "-r"
         (number-to-string my-record-sox-rate)
         "-c"
         (number-to-string my-record-sox-channels)
         my-record-sox-filename))
  (setq my-record-start-time (current-time)))

(defun my-record-current-caption ()
  (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
(defun my-record-send-caption ()
  (setq my-record-caption (my-record-current-caption))
  (when (eq my-record-backend 'obs)
    (obs-websocket-send "SendCaptions" :text (string-trim (my-record-current-caption)))))
(defun my-record-set-start (&optional time)
  (setq my-record-start (my-record-offset-ms time)))
(defun my-record-cancel-segment (&optional time)
  "Reset the start of the current segment and ignore the previous recording."
  (interactive)
  (my-record-set-start time)
  (setq my-record-end nil)
  (my-record-send-caption))

(defun my-record-save-segment (&optional time)
  "Save the current segment in the target file."
  (when (and my-record-start (my-record-current-filename))
    (with-current-buffer (get-buffer-create my-record-segments-buffer)
      (goto-char (point-max))
      (setq my-record-end (or my-record-end (my-record-offset-ms time)))
      (insert "\n\nNOTE: " (my-record-current-filename) "\n"
              (my-msecs-to-timestamp my-record-start) " --> " (my-msecs-to-timestamp my-record-end) "\n"
              (string-trim my-record-caption) "\n")
      (setq my-record-end nil)
      (my-record-set-start time)
      (my-scroll-buffer-to-bottom (current-buffer)))))

(defun my-scroll-buffer-to-bottom (&optional buffer)
  "Scroll buffer to bottom in all its windows."
  (let ((windows (get-buffer-window-list (or buffer (current-buffer)) t t)))
    (dolist (window windows)
      (set-window-point window (point-max)))))

(defun my-record-retry-segment (&optional time)
  "Unpause if needed, copy segment to the other window, and set the beginning time."
  (interactive)
  (my-record-save-segment time)
  (my-record-set-start time)
  (my-record-send-caption))

;; RET Accept segment and move to next one: set end of segment, copy to other side, highlight next segment to say, unpause if needed
;; backspace Cancel segment: reset the start of the current segment, display feedback
;; Left arrow Retry segment: unpause if needed, copy segment to the other window, set beginning time
;; Space Pause recording: use this as the end time; pause recording
;; q Stop recording: accept current segment and then stop
;; Up, down Go to previous or next subtitle: 
;; Ins Edit: cancel segment, stop recording

(defun my-record-previous-segment (&optional time)
  "Cancel segment, set new beginning time, move forward."
  (interactive)
  (forward-line -1)
  (my-record-cancel-segment time))

(defun my-record-next-segment (&optional time)
  "Cancel segment, set new beginning time, move forward."
  (interactive)
  (forward-line 1)
  (my-record-cancel-segment time))

(defun my-record-stop (&optional time)
  "Finish recording."
  (interactive)
  (my-record-save-segment time)
  (cond
   ((eq my-record-backend 'sox)
    (when (process-live-p my-record-sox-process) (quit-process my-record-sox-process)))
   ((eq my-record-backend 'obs)
    (obs-websocket-send "StopRecording"))))

;; (defun my-record-pause ()
;;   "Toggle recording."
;;   (interactive)
;;   (if my-record-paused
;;       (obs-websocket-send "ResumeRecording")
;;     (obs-websocket-send "PauseRecording")
;;     (setq my-record-end (my-obs-websocket-recording-time-msecs)))
;;   (setq my-record-paused (null my-record-paused))
;;   nil)

;; (defun my-record-edit ()
;;   "SomeDocs"
;;   (interactive)
;;   nil)

(defun my-record-accept-segment (&optional time)
  "Accept segment and move to next one: set end of segment, copy to other side, highlight next segment to say."
  (interactive)
  (my-record-save-segment time)
  (forward-line 1)
  (my-record-send-caption))

(defun my-record-setup-windows ()
  (delete-other-windows)  
  (setq my-record-script-buffer (current-buffer))  
  (with-selected-window (split-window-right -40)
    (switch-to-buffer (get-buffer-create my-record-segments-buffer))
    ;; (with-selected-window (split-window-below -10)
    ;;   (switch-to-buffer (my-record-make-buttons)))
    )
  (if my-record-backend (text-scale-set 4)))
(defun my-record-setup ()
  (interactive)
  (my-record-start)
  (setq my-record-segments-buffer
        (find-file-noselect (expand-file-name
                             (concat (file-name-base (my-record-current-filename)) ".vtt")
                             my-record-directory)))
  (my-record-setup-windows)
  (setq my-record-start-time (current-time))
  (my-record-retry-segment)
  (my-record-body))

(defhydra my-record (:exit nil)
  ("SPC" my-stream-toggle-recording (format "Recording [%s]" (if obs-websocket-recording-p "X" " ")))
  ("RET" my-record-accept-segment "Accept")
  ("<backspace>" my-record-cancel-segment "Cancel")
  ("<left>" my-record-retry-segment "Retry")
  ("<up>" my-record-previous-segment "Previous")
  ("<down>" my-record-next-segment "Next")
  ("q" my-record-stop "Stop" :exit t)
  ;; ("SPC" my-record-pause "Pause")
  ;; ("<insert>" my-record-edit "Edit" :exit t)
  )

(defun my-record-make-buttons ()
  (interactive)
  (with-current-buffer (get-buffer-create "*Control*")
    (let ((inhibit-read-only t))
      (erase-buffer)
      (text-scale-set 6)
      (widget-create
       'push-button
       :notify (lambda (&rest ignore)
                 (with-current-buffer my-record-script-buffer
                   (my-record-previous-segment)
                   (set-window-point (selected-window) (point))))
       "Previous")
      (insert "\n")
      (widget-create
       'push-button
       :notify (lambda (&rest ignore) (with-current-buffer my-record-script-buffer (my-record-retry-segment)))
       "Retry")
      (insert "\n")
      (widget-create
       'push-button
       :notify (lambda (&rest ignore) (with-current-buffer my-record-script-buffer
                                        (my-record-accept-segment)
                                        (set-window-point (selected-window) (point))))
       "Accept")
      (widget-setup)
      (widget-minor-mode))
    (current-buffer)))

(defun my-record-start ()
  "Start recording."
  (interactive)
  (cond
   ((eq my-record-backend 'obs)
    (when (not (websocket-openp obs-websocket))
      (obs-websocket-connect))
    (obs-websocket-send "StartRecording"))
   ((eq my-record-backend 'sox) (my-record-sox-start))))

;; (defun my-record-select-line (event)
;;   (interactive "e")
;;   (my-record-save-segment)
;;   (let ((pos (elt (cadr event) 5)))
;;     (goto-char pos)
;;     (beginning-of-line)
;;     (my-record-send-caption)))
;; (defvar my-record-mode-map (make-sparse-keymap))
;; (defvar my-record-mode-map
;;   (let ((map (make-sparse-keymap)))
;;    (define-key map (kbd "SPC") #'my-stream-toggle-recording)
;;     (define-key map (kbd "RET") #'my-record-accept-segment)
;;     (define-key map (kbd "<backspace>") #' my-record-cancel-segment)
;;     (define-key map (kbd "<left>") #' my-record-retry-segment)
;;     (define-key map (kbd "<up>") #' my-record-previous-segment)
;;     (define-key map (kbd "<down>") #' my-record-next-segment)
;;     (define-key map "q" #'my-record-stop)
;;     (define-key map (kbd "C-c C-c") 'my-record-mode)
;;     map))

;; (define-minor-mode my-record-mode 
;;   "Record audio and associate with lines from the current file."
;;   nil
;;   :lighter "rec"
;;   :global nil
;;   :keymap my-record-mode-map
;;   (if my-record-mode
;;       (progn
;;         (message "Now recording..."))
;;     (message "Stopped recording.")))
#+end_src

#+RESULTS:
:results:
my-record-start
:end:

Let's try a subed-based version. Maybe that will be easier for me to manage.

#+begin_src emacs-lisp
(defun my-record-subed-setup ()
  (interactive)
  (my-record-sox-start (concat (file-name-sans-extension (buffer-file-name)) my-record-audio-extension))
  (message "Recording...")
  (my-record-subed/body))

(defun my-record-subed-accept-segment ()
  (interactive)
  (let ((end-time (my-record-offset-ms)))
    (subed-set-subtitle-time-start my-record-start)
    (subed-set-subtitle-time-stop (my-record-offset-ms))
    (subed-forward-subtitle-text)
    (setq my-record-start (my-record-offset-ms))))
(defun my-record-subed-retry ()
  (interactive)
  (setq my-record-start (my-record-offset-ms)))

(defhydra my-record-subed (:exit nil)
  ("<up>" subed-backward-subtitle-text "Previous")
  ("<down>" my-record-subed-accept-segment "Accept")
  ("<left>" my-record-subed-retry "Retry")
  ("q" my-record-stop "Quit" :exit t))

(defun my-subed-add-filenames-to-subtitles ()
  (interactive)
  (goto-char (point-min))
  (while (re-search-forward
          (concat
           "\\(NOTE: .*?\n\\)?\\(" subed-vtt--regexp-timestamp " \\-\\-> " subed-vtt--regexp-timestamp "\n\\)")
          nil t)
    (replace-match (concat "NOTE: " (subed-guess-video-file) "\n" (match-string 2)) t t nil 0)))
#+end_src
#+RESULTS:
:results:
my-record-subed/body
:end:

Split window; left side has the script, right has the notes I'm making
Vtt format
NOTE filename
Start end
Text

Start recording: start OBS recording
RET Accept segment and move to next one: set end of segment, copy to other side, highlight next segment to say, unpause if needed
backspace Cancel segment: reset the start of the current segment, display feedback
Left arrow Retry segment: unpause if needed, copy segment to the other window, set beginning time
Space Pause recording: use this as the end time; pause recording
q Stop recording: accept current segment and then stop
Up, down Go to previous or next subtitle: cancel segment, set new beginning time
Ins Edit: cancel segment, stop recording

And then afterwards, use subed to play back different options

And then write a tool that will take the vtt and spit out the right ffmpeg command to process the webm with a black screen, audio, and subtitles, and a vtt file that's also trimmed.

And then take the images and drop them in

#+begin_src emacs-lisp
(require 'subed-vtt)

(defun my-record-format-as-ffmpeg-selection (list)
  "LIST is a list of (start-ms end-ms text description filename)."
  (let* ((filenames (seq-uniq (mapcar (lambda (o) (elt o 4)) list))))
    (cons
     (mapconcat (lambda (o) (concat "-i " (shell-quote-argument (expand-file-name o)))) filenames " ")
     (mapconcat 'identity
                (seq-map-indexed
                 (lambda (o i)
                   (seq-let (start-ms end-ms text description filename) o
                     (format "[%d:a]aselect='between(t,%.3f,%.3f)',asetpts='N/SR/TB'[r%d];"
                             (seq-position filenames filename 'string=)
                             (/ start-ms 1000.0) (/ end-ms 1000.0)
                             i)))
                 list)
                ""))))

(defun my-record-format-as-audacity-labels (list)
  "LIST is a list of (start-ms end-ms text)."
  (mapconcat
   (lambda (o)
     (format "%0.3f\t%0.3f\t%s\n"
             (/ (car o) 1000.0)
             (/ (cadr o) 1000.0)
             (string-trim (replace-regexp-in-string "[\t\n]+" " " (elt o 2)))))
   list
   ""))

(defun my-record-get-selection-for-region (beg end)
  (interactive "r")
  (goto-char beg)
  (cl-loop
   while (re-search-forward "\\(NOTE: \\(.+?\\)\n\\)?\\(.*?\\) --> \\(.*?\\)\n\\(.*\\)\n\n*" end t)
   collect
   (let* ((filename (match-string 2))
          (start (match-string 3))
          (end (match-string 4))
          (caption (match-string-no-properties 5))
          (start-ms (subed-vtt--timestamp-to-msecs start))
          (end-ms (subed-vtt--timestamp-to-msecs end)))
     (list start-ms end-ms caption nil filename))))

(defun my-record-export-labels (&optional beg end)
  (interactive "r")
  (with-temp-file
      (expand-file-name
       (concat
        (file-name-base (buffer-file-name (or my-record-segments-buffer (current-buffer))))
        ".txt")
       (file-name-directory (buffer-file-name (or my-record-segments-buffer (current-buffer)))))
    (insert (my-record-format-as-audacity-labels
             (with-current-buffer (or my-record-segments-buffer (current-buffer))
               (unless (region-active-p)
                 (setq beg (point-min) end (point-max)))
               (my-record-get-selection-for-region beg end)))))) 
(defvar my-record-recording nil "File to split up.")
(defun my-record-compose-audio (&optional beg end)
  (interactive)
  (let (selection ffmpeg-args
        (file my-record-recording) result)
    (with-current-buffer my-record-segments-buffer
      (goto-char (point-min))
      (setq selection (my-record-get-selection-for-region
                                                             (or beg (point-min))
                                                             (or end (point-max))))
      (setq ffmpeg-args (my-record-format-as-ffmpeg-selection selection)))
    (setq result
          (format "ffmpeg -y %s -filter_complex \"%s%s%s\" -vn -acodec libvorbis %s"
                  (car ffmpeg-args)
                  (cdr ffmpeg-args)
                  (mapconcat (lambda (o) (format "[r%d]" o)) (number-sequence 0 (1- (length selection))) "")
                  (format "concat=n=%d:v=0:a=1" (length selection))
                  "output.ogg"))
    (kill-new result)
    result))


(defun my-record-try-flow (&optional beg end)
  (interactive (list (if (region-active-p) (min (point) (mark)) (point-min))
                     (if (region-active-p) (max (point) (mark)) (point-max))
                     ))
  (save-excursion
    (shell-command-to-string (my-record-compose-audio beg end))
    (mpv-play "output.ogg")))

#+end_src

#+RESULTS:
:results:
my-record-try-flow
:end:

#+begin_export html
<style>
img { filter: drop-shadow(0 0.2rem 0.25rem rgba(0, 0, 0, 0.2)); display: block; width: 50%;  }
.figure p { text-align: left; font-style: italic }
</style>
#+end_export
** Web interface for controlling it

Set httpd-host to the IP address or hostname to have it listen beyond localhost.

#+begin_src emacs-lisp
(use-package simple-httpd)
(defservlet control text/html (path)
  (insert "
  <div id=\"feedback\"></div>
<div class=\"controller\">
  <button onclick=\"javascript:control('retry')\" style=\"background-color: red\">
    Retry
  </button>
  <button onclick=\"javascript:control('previous')\">
    Previous
  </button>
  <button onclick=\"javascript:control('accept')\" style=\"background-color: green\">
    Accept
  </button>
</div>
<style>
 .controller { display: flex; flex-direction: row }
 button { flex-grow: 1; font-size: 70px }
#feedback { font-size: 30px; }
</style>
<script>
function control(op) {
  fetch('/api/' + op + '/' + Date.now()).then(async function(res) {
    document.getElementById('feedback').innerText = await res.text();
  });
}
</script>
"))
(defvar my-record-script-buffer nil)

(defun my-record-web-op (path)
  (when (string-match "^/api/\\(previous\\|retry\\|accept\\)/\\([0-9]+\\)" path)
    (with-current-buffer my-record-script-buffer
      (funcall
       (pcase (match-string 1 path)
         ("previous" 'my-record-previous-segment)
         ("retry" 'my-record-retry-segment)
         ("accept" 'my-record-accept-segment))
       (seconds-to-time (/ (string-to-number (match-string 2 path)) 1000.0)))
      (buffer-substring (point) (save-excursion (forward-line 3) (point))))))

(defservlet api text/html (path)
  (insert (my-record-web-op path)))
#+end_src

#+RESULTS:
:results:
httpd/api
:end:
** Copy images
#+begin_src emacs-lisp
(defvar my-talk-script-heading "Talk plans")
(defvar my-talk-asset-dir "images")
(defun my-talk-copy-assets-to-subdir ()
  (interactive)
  (save-excursion
    (save-restriction
      (narrow-to-region (org-back-to-heading) (save-excursion (org-end-of-subtree)))
      (let (link link-start link-end filename)
        (while (re-search-forward org-link-bracket-re nil t)
          (setq link-start (match-beginning 0)
                link-end (match-end 0)
                link (org-link-unescape (match-string-no-properties 1)))
          (when (and (string-match "^file:\\(.*\\)" link)
                     (setq filename (match-string 1 link))
                     (not (file-in-directory-p filename my-talk-asset-dir)))
            (copy-file filename (expand-file-name (file-name-nondirectory filename) my-talk-asset-dir) t)
            (setq filename (expand-file-name (file-name-nondirectory filename) my-talk-asset-dir))
            (delete-region link-start link-end)
            (insert (org-link-make-string (concat "file:" (file-relative-name filename "."))))))))))
          
#+end_src

#+RESULTS:
:results:
my-talk-copy-assets-to-subdir
:end:

** Emoji support
(set-fontset-font "fontset-default" 'symbol "Noto Color Emoji" nil 'prepend)
** Waveforms

It looks like using the web interface on my phone to accept or retry segments adds too much of a delay, so I need to adjust some timestamps earlier. It might be easier to finetune timestamps if I can see the waveforms. [[https://github.com/larsmagne/wave][wave]] plots PCM data in Emacs. Maybe I can use [[https://trac.ffmpeg.org/wiki/Waveform][ffmpeg's showwavespic filter]] to show it. I think it would generally be useful to be able to see the waveform for a particular segment in a WebVTT subtitle file.

#+begin_src emacs-lisp
(defvar my-record-ffmpeg-executable "ffmpeg")
(defun my-record-get-waveform (sound-file output-file width height &optional start-ms end-ms)
  (setq start-ms (or start-ms 0))
  (let ((args
         (append
          (list "-ss" (format "%.3f" (/ start-ms 1000.0)))
          (if end-ms
              (list "-t" (format "%.3f" (/ (- end-ms start-ms) 1000.0))))
          (list
           "-i"
           sound-file
           "-filter_complex"
           (format "showwavespic=s=%dx%d" width height)
           "-frames:v"
           "1"
           "-y"
           output-file))))
    (apply 'call-process
            my-record-ffmpeg-executable
            nil nil nil
            args)
    ;; (string-join (cons my-record-ffmpeg-executable args) " ")
    output-file))

(defvar my-waveform-height 40)
(defvar my-waveform-clicked-ms nil "Milliseconds of the clicked time on the waveform.")
(defun my-waveform-click (event)
  (interactive "e")
  "Copy the timestamp of the clicked-on image."
  (let* ((x (car (elt 2 (cadr event))))
         (string (elt 4 (cadr event)))
         (time-ms
          (+ (* (/ (* 1.0 x) (get-text-property 0 'width))
                (- (get-text-property 0 'end-ms)
                   (get-text-property 0 'start-ms)))
             (get-text-property 0 'start-ms))))
    (setq my-waveform-clicked-ms time-ms)))

(defvar my-waveform-map
  (let ((map (make-sparse-keymap)))
    (define-key map [mouse-1] #'my-waveform-click)
    map))
(defvar my-waveform-pixels-per-second 100)

(defun my-subed-waveform-pop ()
  
  )

(defun my-subed-make-waveform-string (input output start-ms end-ms waveform-width)
  (let ((string "x"))
    (put-text-property
     0 (length string) 'display
     (create-image
      (my-record-get-waveform
       input
       output
       waveform-width
       my-waveform-height
       start-ms
       end-ms))
     string)
    (put-text-property 0 (length string) 'keymap my-record-waveform-map string)
    (put-text-property 0 (length string) 'start-ms start-ms string)
    (put-text-property 0 (length string) 'end-ms end-ms string)
    (put-text-property 0 (length string) 'width waveform-width string)
    string))

(defun my-subed-get-waveform-at-point ()
  (let* ((filename (concat (make-temp-name temporary-file-directory) ".png"))
         (start-ms (subed-subtitle-msecs-start))
         (end-ms (subed-subtitle-msecs-stop))
         (waveform-width (* 0.001 (- end-ms start-ms) my-waveform-pixels-per-second)))
    (my-subed-make-waveform-string
     (subed-guess-video-file)
     filename
     start-ms
     end-ms
     waveform-width)))

(defun my-subed-show-waveform-after-time ()
  (interactive)
  (save-excursion
    (remove-overlays
     (subed-jump-to-subtitle-time-start)
     (or (subed-jump-to-subtitle-end) (point-max))
     'waveform t)
    (subed-jump-to-subtitle-time-stop)      
    (end-of-line)
    (let ((overlay (make-overlay (point) (point))))
      (overlay-put overlay 'waveform t)  
      (overlay-put overlay 'before-string (my-subed-get-waveform-at-point)))))

(defun my-subed-show-waveforms ()
  (interactive)
  (subed-for-each-subtitle (point-min) (point-max)
    (my-subed-show-waveform-after-time)))

;; (my-record-get-waveform
;;  "~/code/emacsconf-2021-emacs-news-highlights/tmp/2021-10-21-234703.ogg"
;;  "tmp/waveform.png"
;;  2000
;;  60
;;  )
#+end_src
** SVG screenshots
#+begin_src emacs-lisp
(defun screenshot-svg ()
  "Save a screenshot of the current frame as an SVG image.
Saves to a temp file and puts the filename in the kill ring."
  (interactive)
  (let* ((data (x-export-frames nil 'svg))
         (filename (expand-file-name (format-time-string "%Y-%m-%d-%H%M%S.svg") my-screenshot-directory)))
    (with-temp-file filename 
      (insert data))
    (kill-new filename)
    (message filename)))
    #+end_src

    #+RESULTS:
    :results:
    screenshot-svg
    :end:
* Backstory
- rough outline
- filled in with top posts, review of Emacs News Highlights
- draft
- wrapped at ~49 characters with help from display-fill-column-indicator-mode
- recorded audio using a hydra to capture timestamps
- keyboard sound was too loud
- web interface
- visuals
  - images
  - animated GIFs
  - speeding up videos
- burning in captions
- display waveforms
- buttons? but I can't seem to move the point from a button lambda.
- ugh. Next attempt: record longer segments, and then split things
  afterwards.
  
  
* Image credits and sources

- async-python-demo: https://blog.tecosaur.com/tmio/2021-05-31-async.html
- org-roam-ui image: [[https://github.com/org-roam/org-roam-ui][org-roam-ui homepage]]
- bufler taxy magit-section: [[https://www.reddit.com/r/emacs/comments/pkuwcq/and_bufler_taxy_magitsection_a_concise_language/][github-alphapapa]]
- consult-grep animated gif: https://github.com/minad/consult
- orderless screenshot: https://github.com/oantolin/orderless  
- evil-textobj animated gif: https://github.com/meain/evil-textobj-tree-sitter
- parinfer-rust animated gif: https://github.com/justinbarclay/parinfer-rust-mode
- opengl: [[https://www.reddit.com/r/emacs/comments/kn3fzq/draw_anything_to_emacs_buffers_with_opengl/][SnowyHarbor]]
- SVG modelines: https://github.com/ocodo/ocodo-svg-modelines
- Gantt chart: https://github.com/Aightech/org-gantt-svg
- scribble: https://lifeofpenguin.blogspot.com/2021/08/scribble-notes-in-gnu-emacs.html
- el-easydraw diagrams, color picker: https://github.com/misohena/el-easydraw
- svg-icons: https://github.com/rougier/emacs-svg-icon
- svg-lib: https://github.com/rougier/svg-lib
- boxy-headings animated gif: https://gitlab.com/tygrdev/boxy-headings
- boxy-imenu animated gif: https://gitlab.com/tygrdev/boxy-imenu
- org-real animated gif: https://gitlab.com/tygrdev/org-real
- minibuffer interaction paradigm: https://karthinks.com/software/avy-can-do-anything/
