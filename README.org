#+TITLE: Emacs News Highlights
#+OPTIONS: toc:1

| Talk page            | https://emacsconf.org/2021/talks/news            |
| Contact              | Sacha Chua [[mailto:sacha@sachachua.com][sacha@sachachua.com]]                             |
# | Video with subtitles | [[file:emacs-conf-2020-emacs-news-highlights-sacha-chua.webm]] |
# | Audio only           | [[file:audio.ogg]]                                             |

(* 5 150) 750

Draft of my talk for EmacsConf 2021

* Talk plans
:PROPERTIES:
:CUSTOM_ID: script
:END:

#+CAPTION: Emacs News Highlights
[[file:images/Screenshot_20211021_002952.png]] 

I'm Sacha Chua, and here are 
ten Emacs News highlights for 2021.
If you want to follow the links,
check out the wiki page at
https://emacsconf.org/2021/talks/news/ .

#+CAPTION: Emacs NEWS.28
[[file:images/Screenshot_20211020_095333.png]]

1. The Emacs developers are currently
   working on [[https://git.savannah.gnu.org/cgit/emacs.git/tree/etc/NEWS.28][Emacs 28.1]],
   which will be the next major release.

   #+CAPTION: Native compilation featured on System Crafters
   [[file:images/Screenshot_20211020_095812.png]]
   
   [[https://www.youtube.com/watch?v=i8OLg-f9EHk][Native compilation]] should
   make everything way faster,

   #+CAPTION: Emoji support
   [[file:images/EmacslZhRzr.svg]]

   and emoji support will probably
   make things more fun. üòéüëç
   
   John Wiegley will share more Emacs 28 details
   in his update, so check out his talk.

   #+CAPTION: Org Mode 9.5
   [[file:images/Screenshot_20211020_100623.png]]

2. [[https://orgmode.org/Changes.html][Org Mode is now at version 9.5]].
   New features include
   a library for [[https://blog.tecosaur.com/tmio/2021-07-31-citations.html#fn.3][managing citations]],
   
   [[file:images/org-async-python-demo.mp4]]
   
   [[https://blog.tecosaur.com/tmio/2021-05-31-async.html][asynchronous session support]]
   for code blocks,

   #+CAPTION: New faces for agenda
   [[file:images/Screenshot_20211020_101636.png]]

   and better control
   of your [[https://orgmode.org/Changes.html][agenda's appearance]].
   
   #+CAPTION: Org Mode 9.5
   [[file:images/Screenshot_20211020_100623.png]]
   If you've been getting your Org packages
   from Org ELPA,
   you can update your configuration
   to get Org from GNU ELPA
   and org-contrib from NonGNU ELPA.

   #+CAPTION: Org Roam v2
   [[file:images/Screenshot_20211020_101756.png]]

   The [[https://blog.jethro.dev/posts/org_roam_v2/][new release of the Org Roam package]] ([[https://blog.tecosaur.com/tmio/2021-08-38-roaming.html][TMIO]])
   should be a faster and more consistent way
   to use Org to manage a knowledgebase,

   #+CAPTION: Org Roam UI
   [[file:images/org-roam-ui.png]]
   
   and [[https://github.com/org-roam/org-roam-ui/][org-roam-ui]] looks pretty snazzy.

   #+CAPTION: blog.tecosaur.com/tmio
   [[file:images/Screenshot_20211020_101922.png]]

   The best way to keep up with Org changes
   is to check out the blog [[https://blog.tecosaur.com/tmio/][This Month in Org]].

3.
   #+CAPTION: Magit 3.0.0 release notes
   [[file:images/Screenshot_20211020_102028.png]]

   New [[https://emacsair.me/2021/05/25/magit-3.0/][Magit major release]], now version 3.3.
   Jonas Bernoulli has split some functionality
   into other packages so that
   Emacs Lisp developers can use them, such as
   magit-section, transient, and forge.

   #+CAPTION: (and Bufler Taxy Magit-Section)
   [[file:images/Screenshot_20211020_102147.png]]

   Here's an example of using magit-section to
   [[https://www.reddit.com/r/emacs/comments/pkuwcq/and_bufler_taxy_magitsection_a_concise_language/][manage groups of buffers]].

   #+CAPTION: Self-describing Smart DSLs
   [[file:images/Screenshot_20211020_102242.png]]

   You can learn more about Transient
   in the talk on [[https://emacsconf.org/2021/talks/dsl/][self-describing 
   smart domain-specific languages]] or DSLs.
   
4. In terms of smaller packages, there's been
   a lot of activity around completion.
   I think the idea is that instead of having
   one large completion system
   like Helm or Icicles, you can choose
   a few different, smaller packages
   and configure them to work together.
   If you're curious about this, 
   you might start with either
     
     #+CAPTION: selectrum
     [[file:images/Screenshot_20211020_204634.png]]
     [[https://github.com/raxod502/selectrum][selectrum]] 
     #+CAPTION: Vertico
     [[file:images/vertico.svg]]
     or [[https://github.com/minad/vertico][vertico]],
     which are both completion interfaces,

     #+CAPTION: marginalia
     [[file:images/Screenshot_20211020_212130.png]]
     add [[https://github.com/minad/marginalia][marginalia]] for more information
        
     #+CAPTION: consult
     [[file:images/consult-grep.gif]]
     and try [[https://github.com/minad/consult][consult]] for many useful
     completing commands.
     
   #+CAPTION: Discussion on completion frameworks
   [[file:images/Screenshot_20211020_212308.png]]

   There are so many options, 
   so it might be useful to check out
   [[https://www.reddit.com/r/emacs/comments/ppg98f/which_completion_framework_do_you_use_and_why/][some discussions]].
5. 
   #+CAPTION: Embark
   [[file:images/Screenshot_20211020_212456.png]]
   [[https://github.com/oantolin/embark][Embark]] is usually mentioned as part of  
   that group of packages, 
   but it's well worth looking into
   even if you use a different system. 
   It lets you choose an action 
   based on an object, which is handy for 
   when you start with one command 
   and then realize that 
   you actually want to do something else. 
   #+CAPTION: Fifteen ways to use Embark
   [[file:images/Screenshot_20211020_212529.png]]
   For more ideas, check out 
   [[https://karthinks.com/software/fifteen-ways-to-use-embark/][Fifteen Ways to Use Embark]].
6. Now that there are Emacs Lisp bindings 
   for tree-sitter, we can work more easily
   with the structure of code instead of 
   just using regular expressions. 
   You can use tree-sitter for
   #+CAPTION: treesitter-powered snippets
   [[file:images/Screenshot_20211020_212756.png]]
   [[https://blog.meain.io/2021/intelligent-snippets-treesitter/][intelligent snippets]] that get information 
   from the code around them,
   #+CAPTION: symex-ts
   [[file:images/Screenshot_20211020_213017.png]]
   [[https://github.com/polaris64/symex-ts][editing Lisp expressions]], 
   #+CAPTION: evil-textobj
   [[file:images/evil-textobj.gif]]
   and [[https://github.com/meain/evil-textobj-tree-sitter][navigating text objects in Evil mode.]] 
   (That's when Emacs is pretending to be Vi.) 
   Dynamic modules help us add more to Emacs 
   than Emacs Lisp easily offers,
   #+CAPTION: GopCaml
   [[file:images/Screenshot_20211020_213235.png]]
   such as [[https://www.youtube.com/watch?v=KipRuiLXYEo][structural editing in OCaml]]
   #+CAPTION: parinfer-rust
   [[file:images/parinfer-rust.gif]]
   and [[https://github.com/justinbarclay/parinfer-rust-mode#installing][using Rust to figure out parentheses]]
   and indentation for Lisp.
   #+CAPTION: Extending Emacs in Rust with Dynamic Modules
   [[file:images/Screenshot_20211020_213423.png]]
   If you're curious about dynamic modules,
   check out the talk on
   [[https://emacsconf.org/2021/talks/rust/][Extending Emacs in Rust with Dynamic Modules]].
7. 
   #+CAPTION: CRDT - collaborative editing
   [[file:images/Screenshot_20211020_213543.png]]
   Collaborative editing is now much easier 
   since the [[https://elpa.gnu.org/packages/crdt.html][CRDT]] package is in GNU ELPA. ([[https://www.reddit.com/r/emacs/comments/pdi08v/crdtel_the_collaborative_editing_package_now_on/][Reddit]]) 
   It allows multiple people to edit 
   the same file over the network, 
   using their own Emacs. 
   This means you can keep your own config
   and keybindings, yay! 
   #+CAPTION: Emacs Research Group
   [[file:images/Screenshot_20211020_213619.png]]
   Watch the [[https://emacsconf.org/2021/talks/erg/][Emacs Research Group talk]] 
   for an example of how several people 
   used it to work together.
8. In case you're still under the impression 
   that Emacs is just a text editor, 
   some folks have been working on 
   pretty neat graphical experiments.
   #+CAPTION: OpenGL
   [[file:images/opengl.png]]
   These [[https://www.reddit.com/r/emacs/comments/kn3fzq/draw_anything_to_emacs_buffers_with_opengl/][OpenGL bindings for Emacs Lisp]] 
   use an embedded xwidget,
   while other prototypes use the SVG support
   that's built into Emacs
   #+CAPTION: Gantt charts
   [[file:images/Screenshot_20211020_214059.png]]
   for [[https://github.com/Aightech/org-gantt-svg][Gantt charts]] ([[https://www.reddit.com/r/emacs/comments/prezj6/simple_gantt_chart_from_an_org_todo_list_with_svg/][Reddit]]),

   #+CAPTION: Scribble
   [[file:images/scribble.png]]
   [[https://lifeofpenguin.blogspot.com/2021/08/scribble-notes-in-gnu-emacs.html][scribbles]],
   #+CAPTION: el-easydraw
   [[file:images/Screenshot_20211020_214428.png]]
   and even [[https://www.reddit.com/r/emacs/comments/pvtbq5/emacs_drawing_tool/][diagrams]].
   #+CAPTION: el-easydraw color picker
   [[file:images/color-picker-minibuffer.png]]
   The color-picker from that one 
   looks particularly useful for CSS.
   If you want to play around with adding SVGs 
   to your files and interfaces,
   #+CAPTION: svg-icons
   [[file:images/svg-icons.png]]
   [[https://github.com/rougier/emacs-svg-icon][svg icons]]
   #+CAPTION: svg-lib
   [[file:images/svg-lib.png]]
   and [[https://elpa.gnu.org/packages/svg-lib.html][svg-lib]] 
   might be good places to start. ([[https://www.reddit.com/r/emacs/comments/pyee44/svglib_is_on_elpa/][Reddit]])
   Of course, there's always a place 
   for ASCII art,
   #+CAPTION: boxy-headings
   [[file:images/boxy-headings.gif]]
   especially with the new [[https://gitlab.com/tygrdev/boxy][boxy]] package
   that you can use for [[https://www.reddit.com/r/emacs/comments/q2z29f/boxyheadlines_and_orgreal_are_now_on_elpa/][org files]],
   #+CAPTION: boxy-imenu
   [[file:images/boxy-imenu.gif]]
   [[https://gitlab.com/tygrdev/boxy-imenu][imenu navigation]],
   #+CAPTION: org-real
   [[file:images/org-real.gif]]
   and even [[https://gitlab.com/tygrdev/org-real][things in real life]].
9. There have been a lot of great videos 
   and livestreams about Emacs this year.
   #+CAPTION: System Crafters
   [[file:images/Screenshot_20211021_002413.png]]
   In addition to the ones from [[https://systemcrafters.cc/][System Crafters]],
   #+CAPTION: Emacs Elements
   [[file:images/Screenshot_20211021_002120.png]]
   [[https://www.youtube.com/channel/UCe5excZqMeG1CIW-YhMTCEQ][Emacs Elements]],
   #+CAPTION: Protesilaos Stavrou
   [[file:images/Screenshot_20211021_002254.png]]
   and [[https://protesilaos.com/][Protesilaos]] 
   (who has started livestreaming),
   #+CAPTION: John Kitchin
   [[file:images/Screenshot_20211021_002218.png]]
   [[https://www.youtube.com/user/jrkitchin][John Kitchin]]
   #+CAPTION: Mike Zamansky
   [[file:images/Screenshot_20211021_002452.png]]
   and [[https://cestlaz.github.io/categories/emacs/][Mike Zamansky]] 
   are both back, hooray!
10. 
    #+CAPTION: #emacs
    [[file:images/Screenshot_20211021_002604.png]]
    Lastly, if you want to chat 
    with other Emacs folks
    and get help on Emacs, Org Mode, 
    or other topics, the #emacs and #org-mode
    Internet Relay Chat or IRC channels
    are now on the [[https://libera.chat]] network
    instead of Freenode. ([[https://www.emacswiki.org/emacs/EmacsChannel][EmacsWiki]])

#+CAPTION: Emacs News Highlights
[[file:images/Screenshot_20211021_002952.png]]

If you'd like to add something I've missed,
please add them to the collaborative pad
if you're watching this live, 
add them to the wiki page, 
or e-mail me at [[mailto:sacha@sachachua.com][sacha@sachachua.com]] . 
That's all for this quick review. 
Enjoy the rest of EmacsConf 2021!

* Just the text
#+begin_src emacs-lisp
(save-excursion
  (goto-char (org-find-exact-headline-in-buffer "Talk plans"))
  (org-end-of-meta-data)
  (replace-regexp-in-string
   "\\[\\[.*\\]\\[\\(\\([^]]+\\|\n\\)*?\\)\\]\\]"
   "\\2"
   (replace-regexp-in-string "\n[ \t\n]*\n" "\n" (replace-regexp-in-string
                                                  "#\\+CAPTION:.*\n\\|\\[\\[file:.*?\\]\\]" ""
                                                  (buffer-substring-no-properties (point) 
                                                                                  (org-end-of-subtree))))))

#+end_src

#+RESULTS:
:results:

I'm Sacha Chua, and here are 
ten Emacs News highlights for 2021.
If you want to follow the links,
check out the wiki page at
https://emacsconf.org/2021/talks/news/ .
1. The Emacs developers are currently
   working on Emacs 28.1,
   which will be the next major release.
   Native compilation should
   make everything way faster,
   and emoji support will probably
   make things more fun. üòéüëç
   John Wiegley will share more Emacs 28 details
   in his update, so check out his talk.
2. Org Mode is now at version 9.5.
   New features include
   a library for managing citations,
   asynchronous session support
   for code blocks,
   and better control
   of your agenda's appearance.
   If you've been getting your Org packages
   from Org ELPA,
   you can update your configuration
   to get Org from GNU ELPA
   and org-contrib from NonGNU ELPA.
   The TMIO)
   should be a faster and more consistent way
   to use Org to manage a knowledgebase,
   and org-roam-ui looks pretty snazzy.
   The best way to keep up with Org changes
   is to check out the blog This Month in Org.
3.
   New Magit major release, now version 3.3.
   Jonas Bernoulli has split some functionality
   into other packages so that
   Emacs Lisp developers can use them, such as
   magit-section, transient, and forge.
   Here's an example of using magit-section to
   manage groups of buffers.
   You can learn more about Transient
   in the talk on self-describing 
   smart domain-specific languages or DSLs.
4. In terms of smaller packages, there's been
   a lot of activity around completion.
   I think the idea is that instead of having
   one large completion system
   like Helm or Icicles, you can choose
   a few different, smaller packages
   and configure them to work together.
   If you're curious about this, 
   you might start with either
     selectrum 
     or vertico,
     which are both completion interfaces,
     add marginalia for more information
     and try consult for many useful
     completing commands.
   There are so many options, 
   so it might be useful to check out
   some discussions.
5. 
   Embark is usually mentioned as part of  
   that group of packages, 
   but it's well worth looking into
   even if you use a different system. 
   It lets you choose an action 
   based on an object, which is handy for 
   when you start with one command 
   and then realize that 
   you actually want to do something else. 
   For more ideas, check out 
   Fifteen Ways to Use Embark.
6. Now that there are Emacs Lisp bindings 
   for tree-sitter, we can work more easily
   with the structure of code instead of 
   just using regular expressions. 
   You can use tree-sitter for
   intelligent snippets that get information 
   from the code around them,
   editing Lisp expressions, 
   and navigating text objects in Evil mode. 
   (That's when Emacs is pretending to be Vi.) 
   Dynamic modules help us add more to Emacs 
   than Emacs Lisp easily offers,
   such as structural editing in OCaml
   and using Rust to figure out parentheses
   and indentation for Lisp.
   If you're curious about dynamic modules,
   check out the talk on
   Extending Emacs in Rust with Dynamic Modules.
7. 
   Collaborative editing is now much easier 
   since the Reddit) 
   It allows multiple people to edit 
   the same file over the network, 
   using their own Emacs. 
   This means you can keep your own config
   and keybindings, yay! 
   Watch the Emacs Research Group talk 
   for an example of how several people 
   used it to work together.
8. In case you're still under the impression 
   that Emacs is just a text editor, 
   some folks have been working on 
   pretty neat graphical experiments.
   These OpenGL bindings for Emacs Lisp 
   use an embedded xwidget,
   while other prototypes use the SVG support
   that's built into Emacs
   for Reddit),
   scribbles,
   and even diagrams.
   The color-picker from that one 
   looks particularly useful for CSS.
   If you want to play around with adding SVGs 
   to your files and interfaces,
   svg icons
   and svg-lib 
   might be good places to start. (Reddit)
   Of course, there's always a place 
   for ASCII art,
   especially with the new boxy package
   that you can use for org files,
   imenu navigation,
   and even things in real life.
9. There have been a lot of great videos 
   and livestreams about Emacs this year.
   In addition to the ones from System Crafters,
   Emacs Elements,
   and Protesilaos 
   (who has started livestreaming),
   John Kitchin
   and Mike Zamansky 
   are both back, hooray!
10. 
    Lastly, if you want to chat 
    with other Emacs folks
    and get help on Emacs, Org Mode, 
    or other topics, the #emacs and #org-mode
    Internet Relay Chat or IRC channels
    are now on the [[https://libera.chat]] network
    instead of Freenode. (EmacsWiki)
If you'd like to add something I've missed,
please add them to the collaborative pad
if you're watching this live, 
add them to the wiki page, 
or e-mail me at sacha@sachachua.com . 
That's all for this quick review. 
Enjoy the rest of EmacsConf 2021!
:end:


* Tasks
** WAITING Coordinate with johnw
:LOGBOOK:
- State "WAITING"    from "TODO"       [2021-10-20 Wed 09:48] \\
  Waiting for update
:END:
** DONE Record audio
CLOSED: [2021-10-20 Wed 09:48]
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-10-20 Wed 09:48]
:END:
** DONE Collect visuals
CLOSED: [2021-10-21 Thu 00:38]
:PROPERTIES:
:Effort:   1:00
:QUANTIFIED: Emacs
:END:
:LOGBOOK:
- State "DONE"       from "STARTED"    [2021-10-21 Thu 00:38]
CLOCK: [2021-10-20 Wed 09:48]
:END:
** TODO Rerecord audio
** TODO Figure out how to stitch visuals together

ffmpeg?

#+begin_src emacs-lisp

#+end_src

#+RESULTS:
:results:
my-talk-with-script
:end:

Actually, I'd like to get these out of the vtt as well, so I can determine timing.

#+begin_src emacs-lisp
(defmacro my-talk-with-script (&rest body)
  (declare (debug t))
  `(with-current-buffer my-record-script-buffer
     (save-restriction
       (save-excursion
         (goto-char (org-find-exact-headline-in-buffer my-talk-script-heading))
         (narrow-to-region (save-excursion (org-end-of-meta-data) (point)) (save-excursion (org-end-of-subtree)))
         ,@body))))

(defun my-record-segment-get-video-duration-ms (filename)
  (* 1000
     (string-to-number
      (shell-command-to-string
       (concat "ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "
               (shell-quote-argument (expand-file-name filename)))))))

(defun my-record-segment-get-frames (filename)
  (string-to-number
   (shell-command-to-string
    (concat "ffprobe -v error -select_streams v:0 -count_packets -show_entries stream=nb_read_packets -of csv=p=0 "
            (shell-quote-argument (expand-file-name filename))))))

(defun my-record-format-selection-as-visuals (selection)
  (let ((info
         (seq-map-indexed
          (lambda (o i)
            (seq-let (start-ms end-ms caption) o
              (when (string-match "file:\\([^]]+\\)" caption)
                (let ((filename (match-string 1 caption))
                      (duration (- end-ms start-ms)))
                  (cond
                   ((string-match "mp4" caption)
                    (list
                     (format "-i %s" filename)
                     (let ((video-duration (my-record-segment-get-video-duration-ms filename)))
                       (format "[%d:v]setpts=PTS*%.3f,scale=1280:720:force_original_aspect_ratio=decrease,setsar=sar=1,pad=1280:720:(ow-iw)/2:(oh-ih)/2[r%d];"
                               i
                               (/ duration video-duration)
                               i))))
                   ((string-match "gif$" filename)
                    (let ((gif-frames (my-record-segment-get-frames filename)))
                      (list
                       ;; (format "-f image2 -r %0.3f -i %s" (/ (/ duration 1000.0) gif-frames) filename)
                       (format "-i %s" filename)
                       (format "[%d:v]scale=1280:720:force_original_aspect_ratio=decrease,setsar=sar=1,pad=1280:720:(ow-iw)/2:(oh-ih)/2[r%d];" i i))))
                   (t
                    (list
                     (format "-loop 1 -t %0.3f -i %s"
                             (/ duration 1000.0)
                             (shell-quote-argument filename))
                     (format "[%d:v]scale=1280:720:force_original_aspect_ratio=decrease,setsar=sar=1,pad=1280:720:(ow-iw)/2:(oh-ih)/2[r%d];" i i))))))))
          selection)))
    (concat
     (mapconcat 'car info " ")
     " -filter_complex \""
     (mapconcat 'cadr info "")
     (mapconcat
      (lambda (o) (format "[r%d]" o))
      (number-sequence 0 (1- (length selection)))
      "")
     (format "concat=n=%d:v=1:a=0\"" (length selection)))))
(defun my-record-compile-visuals ()
  (interactive)
  (let ((result
         (concat "ffmpeg -y "
                 (with-current-buffer my-record-segments-buffer
                   (my-record-format-selection-as-visuals (my-record-get-selection-for-region (point-min) (point-max))))
                 " -shortest -c:v vp8 -vsync 1 -b:v 800k visuals.webm")))
    (kill-new result)
    result))
(defun my-record-test-visuals ()
  (interactive)
  (let ((result
         (concat "ffmpeg -y "
                 (with-current-buffer my-record-segments-buffer
                   (my-record-format-selection-as-visuals
                    (seq-take
                     (my-talk-with-script
                      (cl-loop
                       while (re-search-forward "\\[\\[file:\\([^]]+\\)\\]" nil t)
                       collect (list 1000 2000 (match-string-no-properties 0))
                       )
                      )
                     10)
                    ))
                 " -shortest -c:v vp8 -vsync 2 -b:v 800k visuals.webm")))
    (kill-new result)
    result)
  )
(my-record-compile-visuals)
#+end_src

#+RESULTS:
:results:
ffmpeg -y -loop 1 -t 0.695 -i images/Screenshot_20211020_095333.png -loop 1 -t 1.723 -i images/Screenshot_20211020_095812.png -loop 1 -t 4.000 -i images/EmacslZhRzr.svg -filter_complex "[0:v]scale=1280:720:force_original_aspect_ratio=decrease,setsar=sar=1,pad=1280:720:(ow-iw)/2:(oh-ih)/2[r0];[1:v]scale=1280:720:force_original_aspect_ratio=decrease,setsar=sar=1,pad=1280:720:(ow-iw)/2:(oh-ih)/2[r1];[2:v]scale=1280:720:force_original_aspect_ratio=decrease,setsar=sar=1,pad=1280:720:(ow-iw)/2:(oh-ih)/2[r2];[r0][r1][r2]concat=n=3:v=1:a=0" -shortest -c:v vp8 -vsync 1 -b:v 800k visuals.webm
:end:
*** TODO handle animated gifs
https://unix.stackexchange.com/questions/40638/how-to-do-i-convert-an-animated-gif-to-an-mp4-or-mv4-on-the-command-line
*** TODO squeeze videos to fit
** TODO Figure out what to do about resolution
1366x768,
wanted 1280x720,
my images are small

** TODO Tweak audio editing
** TODO Tweak caption timing and include it
** TODO Put everything together and send the video
* Code
** STARTED Recording tool
:PROPERTIES:
:CREATED:  [2021-10-19 Tue 21:07]
:Effort:   1:00
:QUANTIFIED: Emacs
:END:
:LOGBOOK:
CLOCK: [2021-10-19 Tue 23:03]
:END:

Goal:

Srt or vtt file with subtitle copies so that I can easily replay segments, delete the ones I don't want to keep, and then use ffmpeg to collapse it into a smooth audio track.

Interface:

#+begin_src emacs-lisp
(obs-websocket-connect)
#+end_src

#+begin_src emacs-lisp
(defvar my-record-backend nil "Either 'sox, 'obs, or nil.")
(defvar my-record-frontend 'hydra "Either 'hydra or 'web.")
(defvar my-record-directory "~/recordings")
(defvar my-record-audio-extension ".wav")
(defvar my-record-start nil "Start of the current recording segment in milliseconds.")
(defvar my-record-end nil "End of current recording sgement in milliseconds.")
(defvar my-record-caption nil "Current caption.")
(defvar my-record-segments-buffer "*Segments*" "Buffer with the segments.")
(defvar my-record-paused nil "If non-nil, recording is currently paused.")

(defvar my-record-sox-process nil "Process for recording via sox.")
(defvar my-record-sox-buffer "*Sox*")
(defvar my-record-sox-executable "rec")
(defvar my-record-sox-channels 1)
(defvar my-record-sox-rate 16000)
(defvar my-record-start-time nil "Emacs timestamp from when the sox process was started.")
(defvar my-record-sox-filename nil)

(defun my-record-current-filename ()
  (cond
   ((eq my-record-backend 'obs) obs-websocket-recording-filename)
   ((eq my-record-backend 'sox) my-record-sox-filename)
   (t "")))
(defun my-record-offset-ms ()
  (cond
   ((eq my-record-backend 'obs) (my-obs-websocket-recording-time-msecs))
   (t (* (float-time (time-subtract (current-time) my-record-start-time)) 1000.0)))) ; sox or nil
   

(defun my-record-sox-start ()
  (interactive)
  (setq my-record-sox-filename
        (expand-file-name
         (concat (format-time-string "%Y-%m-%d-%H%M%S") my-record-audio-extension)
         my-record-directory))
  (setq my-record-sox-buffer
        (get-buffer-create my-record-sox-buffer))
  (if (process-live-p my-record-sox-process)
      (quit-process my-record-sox-process))
  (setq my-record-sox-process
        (start-process
         "sox"
         my-record-sox-buffer
         my-record-sox-executable
         "-r"
         (number-to-string my-record-sox-rate)
         "-c"
         (number-to-string my-record-sox-channels)
         my-record-sox-filename))
  (setq my-record-start-time (current-time)))

(defun my-record-current-caption ()
  (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
(defun my-record-send-caption ()
  (setq my-record-caption (my-record-current-caption))
  (when (eq my-record-backend 'obs)
    (obs-websocket-send "SendCaptions" :text (string-trim (my-record-current-caption)))))
(defun my-record-set-start ()
  (setq my-record-start (my-record-offset-ms)))
(defun my-record-cancel-segment ()
  "Reset the start of the current segment and ignore the previous recording."
  (interactive)
  (my-record-set-start)
  (setq my-record-end nil)
  (my-record-send-caption))

(defun my-record-save-segment ()
  "Save the current segment in the target file."
  (when (and my-record-start (my-record-current-filename))
    (with-current-buffer (get-buffer-create my-record-segments-buffer)
      (goto-char (point-max))
      (setq my-record-end (or my-record-end (my-record-offset-ms)))
      (insert "\n\nNOTE: " (my-record-current-filename) "\n"
              (my-msecs-to-timestamp my-record-start) " --> " (my-msecs-to-timestamp my-record-end) "\n"
              (string-trim my-record-caption) "\n")
      (setq my-record-end nil)
      (my-record-set-start)
      (my-scroll-buffer-to-bottom (current-buffer)))))

(defun my-scroll-buffer-to-bottom (&optional buffer)
  "Scroll buffer to bottom in all its windows."
  (let ((windows (get-buffer-window-list (or buffer (current-buffer)) t t)))
    (dolist (window windows)
      (set-window-point window (point-max)))))

(defun my-record-retry-segment ()
  "Unpause if needed, copy segment to the other window, and set the beginning time."
  (interactive)
  (my-record-save-segment)
  (my-record-set-start)
  (my-record-send-caption))

;; RET Accept segment and move to next one: set end of segment, copy to other side, highlight next segment to say, unpause if needed
;; backspace Cancel segment: reset the start of the current segment, display feedback
;; Left arrow Retry segment: unpause if needed, copy segment to the other window, set beginning time
;; Space Pause recording: use this as the end time; pause recording
;; q Stop recording: accept current segment and then stop
;; Up, down Go to previous or next subtitle: 
;; Ins Edit: cancel segment, stop recording

(defun my-record-previous-segment ()
  "Cancel segment, set new beginning time, move forward."
  (interactive)
  (forward-line -1)
  (my-record-cancel-segment))

(defun my-record-next-segment ()
  "Cancel segment, set new beginning time, move forward."
  (interactive)
  (forward-line 1)
  (my-record-cancel-segment))

(defun my-record-stop ()
  "Finish recording."
  (interactive)
  (my-record-save-segment)
  (cond
   ((eq my-record-backend 'sox)
    (when (process-live-p my-record-sox-process) (quit-process my-record-sox-process)))
   ((eq my-record-backend 'obs)
    (obs-websocket-send "StopRecording"))))

;; (defun my-record-pause ()
;;   "Toggle recording."
;;   (interactive)
;;   (if my-record-paused
;;       (obs-websocket-send "ResumeRecording")
;;     (obs-websocket-send "PauseRecording")
;;     (setq my-record-end (my-obs-websocket-recording-time-msecs)))
;;   (setq my-record-paused (null my-record-paused))
;;   nil)

;; (defun my-record-edit ()
;;   "SomeDocs"
;;   (interactive)
;;   nil)

(defun my-record-accept-segment ()
  "Accept segment and move to next one: set end of segment, copy to other side, highlight next segment to say."
  (interactive)
  (my-record-save-segment)
  (forward-line 1)
  (my-record-send-caption))

(defun my-record-setup (filename)
  (interactive "FSegment VTT: ")
  (setq my-record-segments-buffer (find-file-noselect filename))
  (delete-other-windows)
  (setq my-record-script-buffer (current-buffer))
  (display-buffer (get-buffer-create my-record-segments-buffer))
  (if my-record-backend (text-scale-set 4))
  (setq my-record-start-time (current-time))
  ;; (my-record-minor-mode 1)
  (my-record-start)
  (my-record-retry-segment)

  ;; (my-record/body)
  )

(defhydra my-record (:exit nil)
  ("SPC" my-stream-toggle-recording (format "Recording [%s]" (if obs-websocket-recording-p "X" " ")))
  ("RET" my-record-accept-segment "Accept")
  ("<backspace>" my-record-cancel-segment "Cancel")
  ("<left>" my-record-retry-segment "Retry")
  ("<up>" my-record-previous-segment "Previous")
  ("<down>" my-record-next-segment "Next")
  ("q" my-record-stop "Stop" :exit t)
  ;; ("SPC" my-record-pause "Pause")
  ;; ("<insert>" my-record-edit "Edit" :exit t)
  )

(defun my-record-start ()
  "Start recording."
  (interactive)
  (cond
   ((eq my-record-backend 'obs)
    (when (not (websocket-openp obs-websocket))
      (obs-websocket-connect))
    (obs-websocket-send "StartRecording"))
   ((eq my-record-backend 'sox) (my-record-sox-start))))

;; (defun my-record-select-line (event)
;;   (interactive "e")
;;   (my-record-save-segment)
;;   (let ((pos (elt (cadr event) 5)))
;;     (goto-char pos)
;;     (beginning-of-line)
;;     (my-record-send-caption)))

(defvar my-record-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-c C-c") 'my-record-mode)))

(define-minor-mode my-record-mode ()
  "Record audio and associate with lines from the current file."
  nil
  :lighter "rec"
  :global nil
  (if my-record-minor-mode
      (progn
        (message "Now recording..."))
    (progn
      (my-record-stop)
      (message "Stopped recording."))))
#+end_src

#+RESULTS:
:results:
my-record-start
:end:

Split window; left side has the script, right has the notes I'm making
Vtt format
NOTE filename
Start end
Text

Start recording: start OBS recording
RET Accept segment and move to next one: set end of segment, copy to other side, highlight next segment to say, unpause if needed
backspace Cancel segment: reset the start of the current segment, display feedback
Left arrow Retry segment: unpause if needed, copy segment to the other window, set beginning time
Space Pause recording: use this as the end time; pause recording
q Stop recording: accept current segment and then stop
Up, down Go to previous or next subtitle: cancel segment, set new beginning time
Ins Edit: cancel segment, stop recording

And then afterwards, use subed to play back different options

And then write a tool that will take the vtt and spit out the right ffmpeg command to process the webm with a black screen, audio, and subtitles, and a vtt file that's also trimmed.

And then take the images and drop them in

#+begin_src emacs-lisp
(require 'subed-vtt)
(defun my-record-format-as-ffmpeg-selection (list)
  "LIST is a list of (start-ms end-ms text)."
  (mapconcat
   (lambda (o)
     (format "between(t,%0.3f,%.03f)" (/ (car o) 1000.0) (/ (cadr o) 1000.0)))
   list "+"))
(defun my-record-format-as-audacity-labels (list)
  "LIST is a list of (start-ms end-ms text)."
  (mapconcat
   (lambda (o)
     (format "%0.3f\t%0.3f\t%s\n"
             (/ (car o) 1000.0)
             (/ (cadr o) 1000.0)
             (string-trim (replace-regexp-in-string "[\t\n]+" " " (elt o 2)))))
   list
   ""))

(defun my-record-get-selection-for-region (beg end)
  (interactive "r")
  (goto-char beg)
  (cl-loop
   while (re-search-forward "\\(.*?\\) --> \\(.*?\\)\n\\(.*\\)\n\n*" end t)
   collect
   (let* ((start (match-string 1))
          (end (match-string 2))
          (caption (match-string-no-properties 3))
          (start-ms (subed-vtt--timestamp-to-msecs start))
          (end-ms (subed-vtt--timestamp-to-msecs end)))
     (list start-ms end-ms caption))))

(defun my-record-export-labels (filename &optional beg end)
  (interactive "FFile: \nr")
  (with-temp-file filename
    (insert (my-record-format-as-audacity-labels
             (with-current-buffer my-record-segments-buffer
               (unless (region-active-p)
                 (setq beg (point-min) end (point-max)))
               (my-record-format-as-audacity-labels
                (my-record-get-selection-for-region beg end)))))))
(defvar my-record-recording nil "File to split up.")
(defun my-record-compose-audio (&optional beg end)
  (interactive "r")
  (setq beg (or beg (point-min))
        end (or end (point-max)))
  (let (selection (file my-record-recording) result)
    (with-current-buffer my-record-segments-buffer
      (goto-char (point-min))
      (setq selection (my-record-format-as-ffmpeg-selection (my-record-get-selection-for-region beg end))))
    (setq result
          (format "ffmpeg -y -i %s -af \"aselect='%s',asetpts=N/SR/TB\" -vn -acodec libvorbis %s"
                  (shell-quote-argument file)
                  selection
                  "output.ogg"))
    (kill-new result)
    result))

(defun my-record-try-flow (&optional beg end)
  (interactive (list (if (region-active-p) (min (point) (mark)) (point-min))
                     (if (region-active-p) (max (point) (mark)) (point-max))
                     ))
  (save-excursion
    (shell-command (my-record-compose-audio beg
                                            end))
    (mpv-play "output.ogg")))
#+end_src

#+RESULTS:
:results:
my-record-try-flow
:end:

#+begin_export html
<style>
img { filter: drop-shadow(0 0.2rem 0.25rem rgba(0, 0, 0, 0.2)); display: block; width: 50%;  }
.figure p { text-align: left; font-style: italic }
</style>
#+end_export
** Web interface for controlling it

#+begin_src emacs-lisp
(use-package simple-httpd)
(defservlet record-controller text/html (path)
  (insert "
<div class=\"controller\">
  <button onclick=\"javascript:fetch('/previous')\">
    Previous
  </button>
  <button onclick=\"javascript:fetch('/retry')\" style=\"background-color: red\">
    Retry
  </button>
  <button onclick=\"javascript:fetch('/next')\" style=\"background-color: green\">
    Next
  </button>
</div>
<style>
 .controller { height: 100%; display: flex; flex-direction: column }
 button { flex-grow: 1; font-size: 70px } 
</style>"))
(defvar my-record-script-buffer nil)
(defservlet previous application/json ()
  (with-current-buffer my-record-script-buffer
   (my-record-previous-segment))
  (insert "{true}"))
(defservlet retry application/json ()
  (with-current-buffer my-record-script-buffer
  (my-record-cancel-segment))
  (insert "{true}"))
(defservlet next application/json ()
  (with-current-buffer my-record-script-buffer
    (my-record-accept-segment))
  (insert "{true}"))
#+end_src

#+RESULTS:
:results:
httpd/next
:end:
** Copy images
#+begin_src emacs-lisp
(defvar my-talk-script-heading "Talk plans")
(defvar my-talk-asset-dir "images")
(defun my-talk-copy-assets-to-subdir ()
  (interactive)
  (save-excursion
    (save-restriction
      (narrow-to-region (org-back-to-heading) (save-excursion (org-end-of-subtree)))
      (let (link link-start link-end filename)
        (while (re-search-forward org-link-bracket-re nil t)
          (setq link-start (match-beginning 0)
                link-end (match-end 0)
                link (org-link-unescape (match-string-no-properties 1)))
          (when (and (string-match "^file:\\(.*\\)" link)
                     (setq filename (match-string 1 link))
                     (not (file-in-directory-p filename my-talk-asset-dir)))
            (copy-file filename (expand-file-name (file-name-nondirectory filename) my-talk-asset-dir) t)
            (setq filename (expand-file-name (file-name-nondirectory filename) my-talk-asset-dir))
            (delete-region link-start link-end)
            (insert (org-link-make-string (concat "file:" (file-relative-name filename "."))))))))))
          
#+end_src

#+RESULTS:
:results:
my-talk-copy-assets-to-subdir
:end:

** Emoji support
(set-fontset-font "fontset-default" 'symbol "Noto Color Emoji" nil 'prepend)
** SVG screenshots
#+begin_src emacs-lisp
(defun screenshot-svg ()
  "Save a screenshot of the current frame as an SVG image.
Saves to a temp file and puts the filename in the kill ring."
  (interactive)
  (let* ((data (x-export-frames nil 'svg))
         (filename (expand-file-name (format-time-string "%Y-%m-%d-%H%M%S.svg") my-screenshot-directory)))
    (with-temp-file filename 
      (insert data))
    (kill-new filename)
    (message filename)))
    #+end_src

    #+RESULTS:
    :results:
    screenshot-svg
    :end:

* Image credits and sources

- async-python-demo: https://blog.tecosaur.com/tmio/2021-05-31-async.html
- org-roam-ui image: [[https://github.com/org-roam/org-roam-ui][org-roam-ui homepage]]
- bufler taxy magit-section: [[https://www.reddit.com/r/emacs/comments/pkuwcq/and_bufler_taxy_magitsection_a_concise_language/][github-alphapapa]]
- consult-grep animated gif: https://github.com/minad/consult
- orderless screenshot: https://github.com/oantolin/orderless  
- evil-textobj animated gif: https://github.com/meain/evil-textobj-tree-sitter
- parinfer-rust animated gif: https://github.com/justinbarclay/parinfer-rust-mode
- opengl: [[https://www.reddit.com/r/emacs/comments/kn3fzq/draw_anything_to_emacs_buffers_with_opengl/][SnowyHarbor]]
- SVG modelines: https://github.com/ocodo/ocodo-svg-modelines
- Gantt chart: https://github.com/Aightech/org-gantt-svg
- scribble: https://lifeofpenguin.blogspot.com/2021/08/scribble-notes-in-gnu-emacs.html
- el-easydraw diagrams, color picker: https://github.com/misohena/el-easydraw
- svg-icons: https://github.com/rougier/emacs-svg-icon
- svg-lib: https://github.com/rougier/svg-lib
- boxy-headings animated gif: https://gitlab.com/tygrdev/boxy-headings
- boxy-imenu animated gif: https://gitlab.com/tygrdev/boxy-imenu
- org-real animated gif: https://gitlab.com/tygrdev/org-real
